<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>PlotOMatic v0.5g — Toolbar Semantic Consolidation (Phase 1)</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 12px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .panel { display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap; }
    .box { border:1px solid #ddd; border-radius:12px; padding:10px; }
    canvas { border: 1px solid #999; cursor: crosshair; display:block; margin-top:10px; }
    label { display:inline-flex; gap:6px; align-items:center; }
    input[type="number"]{ width: 92px; }
    textarea { width: 100%; height: 180px; margin-top:10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 0.9rem; color:#444; }
    .hint { color:#555; font-size: 0.95rem; margin-top:8px; line-height: 1.3; }
    .btn { padding: 4px 10px; border:1px solid #ccc; border-radius:12px; background:#fff; cursor:pointer; }
    .btn:hover { background:#f6f6f6; }
    .btn.on { border-color:#444; background:#f2f2f2; }
    .seg { border-top:1px dashed #ddd; margin-top:10px; padding-top:10px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; }
    th { background:#fafafa; position: sticky; top:0; text-align:left; }
    td.r { text-align:right; }
    .warn { color:#b00; }
    .ok { color:#070; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:0.85rem; }

    .groupTitle{ font-weight:700; margin-bottom:6px; }
    .toolGroup{ border:1px solid #e5e5e5; border-radius:12px; padding:10px; margin-top:10px; }
    .toolGroup .row{ margin-top:6px; }
    .toolGroup .row:first-child{ margin-top:0; }
    .canvasbar{ display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .canvasbar .left, .canvasbar .right{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }


    #toolMeaningRow{
        padding: 4px 8px;
        border: 1px dashed #777;
         border-radius: 6px;
        }
        #toolMeaningText{
         margin-left: 8px;
        opacity: 0.95;
        }

tr.entityRow.selected { background: #f2f2f2; }

tr.entityRow .dots{
  display:none;
  padding:2px 8px;
  border:1px solid #777;
  border-radius:6px;
  background:transparent;
  cursor:pointer;
  font-size:14px;
  line-height:18px;
}

tr.entityRow.selected .dots{ display:inline-block; }

</style>
</head>
<body>

<h3>PlotOMatic v0.5g — Toolbar Semantic Consolidation (Phase 1)</h3>

<div class="panel">

  <div class="box">

    <div class="toolGroup" id="viewGroup">
      <div class="groupTitle">View</div>
      <div class="row">
      <label>Units:
        <select id="units">
          <option value="in">Inches</option>
          <option value="mm">Millimeters</option>
        </select>
      </label>

      <label>Grid step:
        <input id="gridStep" type="number" value="0.25" step="0.01" min="0.001">
      </label>

      <label>Snap:
        <input id="snap" type="checkbox" checked>
      </label>

      <label>Major every:
        <input id="majorEvery" type="number" value="4" step="1" min="1">
      </label>

      <label>View width:
        <input id="viewWidth" type="number" value="12" step="0.5" min="1">
      </label>

      <button id="apply" class="btn">Apply</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <label>Coord flavor:
        <select id="coordFlavor">
          <option value="neutral">Neutral</option>
          <option value="haas">Haas Work (X0,Y0)</option>
        </select>
      </label>

      <label>X0:
        <input id="x0" type="number" value="0" step="0.001">
      </label>
      <label>Y0:
        <input id="y0" type="number" value="0" step="0.001">
      </label>

      <button id="setZero" class="btn">Set X0,Y0</button>
      <button id="pickZero" class="btn">Pick X0,Y0</button>

      
      <button id="centerViewZero" class="btn" type="button">Center View on X0,Y0</button>
      <button id="resetView" class="btn" type="button">Reset View</button>

    </div>
    </div>

    <div class="toolGroup" id="sessionGroup">
  <div class="groupTitle">Session</div>
  <div class="row">
    <button id="snapshot" class="btn">Snapshot</button>
    <button id="saveSessionAs" class="btn">Save Session As…</button>
    <button id="loadSession" class="btn">Load Saved Session…</button>
    <input id="loadSessionFile" type="file" accept=".json,application/json" style="display:none;">
  </div>
  <div class="small hint">Session = canonical authoring state (resume work). Exports are generated separately.</div>
</div>

<div class="toolGroup" id="exportGroup">
  <div class="groupTitle">Export</div>
  <div class="row">
    <label>Export:
      <select id="exportMode">
        <option value="csv">CSV</option>
        <option value="gcode">G-code</option>
        <option value="pmir">PseudoMatic IR (Core1)</option>
        <option value="teach">Teaching Pseudocode</option>
      </select>
    </label>

    <label class="small" style="gap:6px;">
      <input id="markPoints" type="checkbox" checked>
      Render DATUM points as marks
    </label>

    <label>Pseudocode verb:
      <select id="psVerb">
        <option value="MOVE_TO">MOVE_TO</option>
        <option value="GO_TO">GO_TO</option>
        <option value="LINE_TO">LINE_TO</option>
      </select>
    </label>

    <button id="export" class="btn">Export</button>
  </div>
  <div class="small hint">Export = derived output (regenerable). Not saved inside session.</div>
</div>

      <div class="toolGroup" id="drawGroup">
      <div class="groupTitle">Draw</div>
      <div class="row">
        <button id="toolPoint" class="btn on">Point</button>
        <button id="toolDrill" class="btn">Drill</button>
        <button id="toolLine" class="btn">Line</button>
        <button id="toolPolyline" class="btn">Polyline</button>
        <label class="small" style="gap:6px; align-items:center;">
          <input id="polyClosed" type="checkbox">
          Closed
        </label>
        <button id="toolArc3" class="btn">Arc (3pt)</button>
        <button id="toolCircle2" class="btn">Circle (Center+R)</button>
        <button id="toolRect2" class="btn">Rectangle</button>
    
        <label>Curve sample step:
          <input id="sampleStep" type="number" value="0.10" step="0.01" min="0.001">
        </label>
      </div>
      
      <!-- RUMBLE STRIP: Tool meaning (mobile-safe, no hover required) -->
      <div class="row" id="toolMeaningRow" style="margin-top:6px;">

    <b>Tool</b>
    <span class="muted">(• Tip: Hold Shift to temporarily disable snap)</span>:

        <span class="small" id="toolMeaningText">—</span>
      </div>
    </div>


      <div class="toolGroup" id="generatorsGroup">
<div class="seg" style="margin-top:10px;">
      <div class="groupTitle">Generators</div>

      <div class="row" style="margin-top:6px; align-items:center; flex-wrap:wrap;">
        <span class="small"><b>N-gon</b></span>
        <label class="small">Sides
          <input id="ngonSides" type="number" min="3" step="1" value="6" style="width:70px;">
        </label>
        <label class="small">Radius
          <input id="ngonRadius" type="number" step="0.1" value="1.0" style="width:90px;">
        </label>
        <label class="small">Start ° 
          <input id="ngonStartDeg" type="number" step="1" value="0" style="width:70px;">
        </label>
        <button id="ngonCenterFromCursor" class="btn" type="button">Center = cursor</button>
        <label class="small">Center X
          <input id="ngonCx" type="number" step="0.1" value="0" style="width:90px;">
        </label>
        <label class="small">Center Y
          <input id="ngonCy" type="number" step="0.1" value="0" style="width:90px;">
        </label>
        <label class="small" style="gap:6px; align-items:center;">
          <input id="ngonAsPolyline" type="checkbox" checked>
          Polyline
        </label>
        <label class="small" style="gap:6px; align-items:center;">
          <input id="ngonAsDrills" type="checkbox">
          Drills at vertices
        </label>
        <button id="ngonMake" class="btn" type="button">Create</button>
      </div>

      <div class="row" style="margin-top:8px; align-items:center; flex-wrap:wrap;">
        <span class="small"><b>Circle subdivision</b></span>
        <label class="small">Divisions
          <input id="subDiv" type="number" min="3" step="1" value="12" style="width:70px;">
        </label>
        <label class="small">Radius
          <input id="subRadius" type="number" step="0.1" value="1.0" style="width:90px;">
        </label>
        <label class="small">Start °
          <input id="subStartDeg" type="number" step="1" value="0" style="width:70px;">
        </label>
        <button id="subCenterFromCursor" class="btn" type="button">Center = cursor</button>
        <label class="small">Center X
          <input id="subCx" type="number" step="0.1" value="0" style="width:90px;">
        </label>
        <label class="small">Center Y
          <input id="subCy" type="number" step="0.1" value="0" style="width:90px;">
        </label>

        <label class="small" style="gap:6px; align-items:center;">
          <input id="subAsDrills" type="checkbox" checked>
          Drills
        </label>
        <label class="small" style="gap:6px; align-items:center;">
          <input id="subAsPolygon" type="checkbox">
          Polygon (polyline)
        </label>
        <button id="subMake" class="btn" type="button">Create</button>
      </div>

      <div class="small hint">
        Notes: N-gon and subdivision share the same vertex math. Subdivision can also create a polygon; N-gon can optionally add drill points at vertices.
      </div>
    </div>
</div>

<!-- UNDERLAY (Tracing overlay) -->
      <div class="seg" style="margin-top:8px;">
        <div class="small"><b>Tracing Underlay</b> (image overlay)</div>
        <div class="row" style="margin-top:6px; align-items:center;">
          <input id="underlayFile" type="file" accept="image/*" class="small">
          <button id="underlayClear" class="btn" type="button">Clear</button>
          <label class="small" style="gap:6px; align-items:center;">
            <input id="underlayLock" type="checkbox" checked>
            Lock
          </label>
        </div>
        <div class="row" style="margin-top:6px; align-items:center; flex-wrap:wrap;">
          <label class="small">Opacity
            <input id="underlayOpacity" type="range" min="0" max="1" step="0.01" value="0.45" style="width:160px;">
          </label>
          <label class="small">Scale (mm/px)
            <input id="underlayScale" type="number" step="0.01" value="1.00" style="width:90px;">
          </label>
          <button id="underlayFit" class="btn" type="button">Fit to View</button>
          <label class="small">W
            <input id="underlayW" type="number" step="0.1" placeholder="(units)" style="width:90px;">
          </label>
          <label class="small">H
            <input id="underlayH" type="number" step="0.1" placeholder="(units)" style="width:90px;">
          </label>
          <button id="underlayApplySize" class="btn" type="button">Apply Size</button>

          <label class="small">X
            <input id="underlayX" type="number" step="0.1" value="0" style="width:90px;">
          </label>
          <label class="small">Y
            <input id="underlayY" type="number" step="0.1" value="0" style="width:90px;">
          </label>
          <button id="underlayToCursor" class="btn" type="button">Set XY to cursor</button>
          <button id="underlayReset" class="btn" type="button">Reset</button>
        </div>
        <div class="small hint">
          Tip: Load a photo/drawing, adjust opacity/scale, set XY, then trace with Line/Polyline/Arc/Circle.
          (Tip: unlock + Alt-drag to slide image under grid. Use W/H or Fit to match grid scale.)
        </div>
      </div>
    </div>


<div class="canvasbar">
  <div class="left">
    <span class="pill" id="featureHint"></span>
    <button id="undo" class="btn" type="button">Undo</button>
    <button id="redo" class="btn" type="button">Redo</button>
    <button id="clear" class="btn" type="button">Clear</button>
  </div>
  <div class="right">
    <span id="readout" class="mono"></span>
  </div>
</div>

    <canvas id="cv" width="1100" height="650"></canvas>
    <textarea id="out" class="mono" placeholder="Export will appear here..."></textarea>



<div class="seg" id="csvPane">
  <div class="row" style="justify-content:space-between; align-items:center;">
    <div class="small"><b>Live CSV (Active feature)</b> <span class="small" id="csvStatus"></span></div>
    <div class="row" style="gap:6px;">
      <label class="small">CSV Mode:
        <select id="csvMode">
          <option value="segments" selected>Segments (CNC)</option>
          <option value="waypoints">Waypoints (Sampled)</option>
        </select>
      </label>
      <button id="copyCsv" class="btn">Copy CSV</button>
    </div>
  </div>
  <textarea id="csvLive" class="mono" style="height:160px;" placeholder="Live CSV will appear here as you add points..."></textarea>
</div>





 </div>

  <div class="box" style="min-width:420px; flex: 0 0 520px;">
    <div class="small"><b>Entities</b> (Active feature) — count: <span id="entCount">0</span></div>
    <div style="max-height:320px; overflow:auto; margin-top:6px;">
      <table>
        <thead>
          <tr><th>#</th><th>Type</th><th>Summary</th><th></th></tr>
        </thead>
        <tbody id="entTable"></tbody>
      </table>
    </div>

<div class="seg">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div class="small"><b>Flattened Points</b> (Active feature, for export) — count: <span id="ptCount">0</span></div>
        <label class="small" style="gap:6px;">
          <input id="showDerived" type="checkbox" checked>
          Show derived points
        </label>
      </div>
      <div class="hint small">Point entities are editable. Curve/path points are derived.</div>
      <div id="ptTableWrap" style="max-height:340px; overflow:auto; margin-top:6px;">
      <table>
          <thead>
            <tr>
              <th>N</th><th class="r">X</th><th class="r">Y</th><th>Src</th>
            </tr>
          </thead>
          <tbody id="ptTable"></tbody>
        </table>
      </div>
    </div>
  </div>

</div>

<script>
/* =========================
   Core units + view
========================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

const U = {
  in: { name:"in", toMM: 25.4, decimals: 4 },
  mm: { name:"mm", toMM: 1.0,  decimals: 3 }
};

let state = {
  units: "in",
  gridStep_u: 0.25,
  majorEvery: 4,
  viewWidth_u: 12,
  coordFlavor: "haas",
  center_world_mm: {x: 0, y: 0},
  workZero_world_mm: {x: 0, y: 0},
};


/* =========================
   Core1 IR semantics (v0.4j1)
   PURPOSE is an IR-level contract: SKETCH vs MACHINE.
   Z_STRATEGY is stubbed/enforced in MACHINE mode (no Z motion yet).
========================= */
let IR_PURPOSE = "SKETCH";        // "SKETCH" | "MACHINE" (default safe)
let IR_Z_STRATEGY = "UNDECLARED"; // "DECLARED" | "UNDECLARED"

function uToMM(v_u){ return v_u * U[state.units].toMM; }
function mmToU(v_mm){ return v_mm / U[state.units].toMM; }
function viewHeight_u(){ return state.viewWidth_u * (cv.height / cv.width); }

function w2s_world_mm(x_mm, y_mm){
  const vw_mm = uToMM(state.viewWidth_u);
  const vh_mm = uToMM(viewHeight_u());
  const xmin = state.center_world_mm.x - vw_mm/2;
  const ymin = state.center_world_mm.y - vh_mm/2;
  const sx = (x_mm - xmin) / vw_mm * cv.width;
  const sy = cv.height - ( (y_mm - ymin) / vh_mm * cv.height );
  return {sx, sy};
}
function s2w_world_mm(sx, sy){
  const vw_mm = uToMM(state.viewWidth_u);
  const vh_mm = uToMM(viewHeight_u());
  const xmin = state.center_world_mm.x - vw_mm/2;
  const ymin = state.center_world_mm.y - vh_mm/2;
  const x_mm = xmin + (sx / cv.width) * vw_mm;
  const y_mm = ymin + ((cv.height - sy) / cv.height) * vh_mm;
  return {x_mm, y_mm};
}

// world <-> recorded (feature coords)
function worldToRec_mm(xw, yw){
  if (state.coordFlavor === "haas"){
    return { x_mm: xw - state.workZero_world_mm.x, y_mm: yw - state.workZero_world_mm.y };
  }
  return { x_mm: xw, y_mm: yw };
}
function recToWorld_mm(x, y){
  if (state.coordFlavor === "haas"){
    return { xw_mm: x + state.workZero_world_mm.x, yw_mm: y + state.workZero_world_mm.y };
  }
  return { xw_mm: x, yw_mm: y };
}

function roundToStep(value_u, step_u){
  return Math.round(value_u / step_u) * step_u;
}
function snapRec(rec, snapEnabled){
  if (!snapEnabled) return rec;
  let x_u = mmToU(rec.x_mm);
  let y_u = mmToU(rec.y_mm);
  x_u = roundToStep(x_u, state.gridStep_u);
  y_u = roundToStep(y_u, state.gridStep_u);
  return { x_mm: uToMM(x_u), y_mm: uToMM(y_u) };
}

/* =========================
   Data model: Features + Entities
========================= */
const FEATURES = ["DRILL","CONTOUR","POCKET","REF"];
const featureHints = {
  DRILL: "Unconnected points/circles for drilling patterns.",
  CONTOUR: "Connected path entities (polyline/arc).",
  POCKET: "Closed boundaries (polyline/circle) as pocket outlines.",
  REF: "Construction geometry (no export)."
};

let activeFeature = "DRILL";

let entities = []; // {id, feature, type, ...params}
let nextId = 1;

// =========================
// Tracing underlay (image overlay)
// =========================
const underlay = {
  img: null,
  opacity: 0.45,
  mmPerPx: 1.0,
  x_mm: 0,   // world mm location of image top-left
  y_mm: 0,   // world mm location of image top-left
  locked: true,
  // persistence fields for Save Session As
  dataUrl: null,
  name: null,
  mime: null
};


// Undo/Redo history (snapshot-based; simple & robust)
let undoStack = [];
let redoStack = [];
const HISTORY_LIMIT = 200;

function snapshotState(){
  // Only snapshot mutable editor state (not view settings)
  return JSON.stringify({
    entities,
    nextId,
    polyTemp,
    lineTemp,
    arcTemp,
    circTemp,
    rectTemp,
    activeFeature,
    tool
  });
}
function restoreSnapshot(snap){
  const st = JSON.parse(snap);
  entities = st.entities;
  nextId = st.nextId;
  polyTemp = st.polyTemp || [];
  lineTemp = st.lineTemp || [];
  arcTemp = st.arcTemp || [];
  circTemp = st.circTemp || [];
  rectTemp = st.rectTemp || [];
  activeFeature = st.activeFeature || activeFeature;
  tool = st.tool || tool;
  // reflect active feature selector + tool button highlighting
  const featureSel = document.getElementById("feature");
  if (featureSel) featureSel.value = activeFeature;
  // keep tool button state coherent
  [btnPoint,btnDrill,btnLine,btnPoly,btnArc3,btnCircle2,btnRect2].forEach(b=>b.classList.remove("on"));
  ({POINT:btnPoint, DRILL:btnDrill, LINE:btnLine, POLYLINE:btnPoly, ARC3:btnArc3, CIRCLE2:btnCircle2}[tool]).classList.add("on");
  redraw();
}

function pushHistory(){
  undoStack.push(snapshotState());
  if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
  // any new action invalidates redo history
  redoStack = [];
}
function canUndo(){ return undoStack.length > 0; }
function canRedo(){ return redoStack.length > 0; }


function addEntity(ent){
  pushHistory();
  ent.id = nextId++;
  entities.push(ent);
}
function deleteEntity(id){
  pushHistory();
  entities = entities.filter(e => e.id !== id);
}
function getEntitiesForFeature(f){
  return entities.filter(e => e.feature === f);
}

/* =========================
   Geometry helpers
========================= */
function circleFrom3(p1, p2, p3){
  const x1=p1.x_mm, y1=p1.y_mm;
  const x2=p2.x_mm, y2=p2.y_mm;
  const x3=p3.x_mm, y3=p3.y_mm;
  const a = x1*(y2 - y3) - y1*(x2 - x3) + x2*y3 - x3*y2;
  if (Math.abs(a) < 1e-10) return null;
  const b = (x1*x1 + y1*y1)*(y3 - y2) + (x2*x2 + y2*y2)*(y1 - y3) + (x3*x3 + y3*y3)*(y2 - y1);
  const c = (x1*x1 + y1*y1)*(x2 - x3) + (x2*x2 + y2*y2)*(x3 - x1) + (x3*x3 + y3*y3)*(x1 - x2);
  const cx = -b / (2*a);
  const cy = -c / (2*a);
  const r = Math.hypot(cx - x1, cy - y1);
  return {cx, cy, r};
}
function angle(cx,cy, x,y){ return Math.atan2(y - cy, x - cx); }
function mod2pi(t){ const two=2*Math.PI; t=t%two; if(t<0)t+=two; return t; }

function sampleArc3(pS, pM, pE, step_u){
  const circ = circleFrom3(pS,pM,pE);
  if (!circ) return null;
  const {cx,cy,r} = circ;
  const aS = angle(cx,cy,pS.x_mm,pS.y_mm);
  const aM = angle(cx,cy,pM.x_mm,pM.y_mm);
  const aE = angle(cx,cy,pE.x_mm,pE.y_mm);
  const sweepSE = mod2pi(aE - aS);
  const sweepSM = mod2pi(aM - aS);
  const ccw = (sweepSM <= sweepSE);
  const sweep = ccw ? sweepSE : mod2pi(aS - aE);

  const step_mm = uToMM(step_u);
  const arcLen = r * sweep;
  const n = Math.max(6, Math.ceil(arcLen / step_mm) + 1);

  let pts = [];
  for (let i=0;i<n;i++){
    const t = i/(n-1);
    const ang = ccw ? (aS + t*sweepSE) : (aS - t*mod2pi(aS - aE));
    pts.push({x_mm: cx + r*Math.cos(ang), y_mm: cy + r*Math.sin(ang)});
  }
  return {ccw, cx, cy, r, pts};
}

function sampleCircle(center, radPt, step_u){
  const cx=center.x_mm, cy=center.y_mm;
  const r = Math.hypot(radPt.x_mm - cx, radPt.y_mm - cy);
  if (r < 1e-10) return null;

  const step_mm = uToMM(step_u);
  const circ = 2*Math.PI*r;
  const n = Math.max(24, Math.ceil(circ/step_mm));
  let out = [];
  for (let i=0;i<=n;i++){
    const ang = (i/n) * 2*Math.PI;
    out.push({x_mm: cx + r*Math.cos(ang), y_mm: cy + r*Math.sin(ang)});
  }
  return {cx, cy, r, pts: out};
}

function setToolMeaning(text){
  const el = document.getElementById("toolMeaningText");
  if (!el) return;
  const base = String(text || "—");
  // Keep it mobile-safe: a single “rumble strip” line that updates with the active tool.
  el.textContent = base + "  •  " + (typeof TOOL_GLOBAL_HINT === "string" ? TOOL_GLOBAL_HINT : "");
}




/* =========================
   Flatten feature -> points
   (Maintainable: one place defines export geometry.)
========================= */
function flattenFeaturePoints(feature){
  const step_u = Number(document.getElementById("sampleStep").value);
  let out = []; // {x_mm,y_mm, src, editable?, entId?}

  for (const e of getEntitiesForFeature(feature)){
    if (e.type === "POINT"){
      out.push({x_mm:e.p.x_mm, y_mm:e.p.y_mm, src:`POINT#${e.id}`, editable:true, entId:e.id});
    } else if (e.type === "LINE"){
      out.push({x_mm:e.A.x_mm, y_mm:e.A.y_mm, src:`LINE#${e.id}:A`});
      out.push({x_mm:e.B.x_mm, y_mm:e.B.y_mm, src:`LINE#${e.id}:B`});
    } else if (e.type === "POLYLINE"){
      if (Array.isArray(e.pts)){
        e.pts.forEach((p,idx)=> out.push({x_mm:p.x_mm, y_mm:p.y_mm, src:`POLY#${e.id}:${idx+1}`}));
        if (e.closed && e.pts.length > 1){
          const p0 = e.pts[0];
          out.push({x_mm:p0.x_mm, y_mm:p0.y_mm, src:`POLY#${e.id}:CLOSE`});
        }
      }
    } else if (e.type === "ARC3"){
      const res = sampleArc3(e.S, e.M, e.E, step_u);
      if (res) res.pts.forEach((p,idx)=> out.push({x_mm:p.x_mm, y_mm:p.y_mm, src:`ARC#${e.id}:${idx+1}`}));
    } else if (e.type === "CIRCLE2"){
      const res = sampleCircle(e.C, e.RP, step_u);
      if (res) res.pts.forEach((p,idx)=> out.push({x_mm:p.x_mm, y_mm:p.y_mm, src:`CIRC#${e.id}:${idx+1}`}));
    }
  }
  return out;
}


/* =========================
   CSV Pane
========================= */

function exportWaypointsCSV(feature){
  const pts = flattenFeaturePoints(feature);
  const d = U[state.units].decimals;
  let lines = ["N,X,Y,UNITS,SRC"];
  pts.forEach((p,i)=>{
    lines.push(`${i+1},${mmToU(p.x_mm).toFixed(d)},${mmToU(p.y_mm).toFixed(d)},${state.units},${p.src}`);
  });
  return lines.join("\n");
}

// Segments = intent rows (CNC-friendly): one row per motion, not sampled points.
// DRILL: emits one row per POINT entity.
// CONTOUR/POCKET: POLYLINE vertices become FEED_TO segments; ARC3 becomes ARC_CW/CCW with I,J from start.
function exportSegmentsCSV(feature){
  const ents = getEntitiesForFeature(feature);
  const d = U[state.units].decimals;
  let n = 0;
  const lines = ["N,ACTION,X,Y,I,J,UNITS,SRC"];

  for (const e of ents){
    // DRILL: independent points (hole centers)
    if (feature === "DRILL"){
      if (e.type === "POINT"){
        n++;
        lines.push(`${n},DRILL_POINT,${mmToU(e.p.x_mm).toFixed(d)},${mmToU(e.p.y_mm).toFixed(d)},,,${state.units},POINT#${e.id}`);
      }
      // DRILL circles are possible later; for now, treat as reference-only.
      continue;
    }

    // POINT in non-DRILL features: marker/reference
    if (e.type === "POINT"){
      n++;
      lines.push(`${n},POINT,${mmToU(e.p.x_mm).toFixed(d)},${mmToU(e.p.y_mm).toFixed(d)},,,${state.units},POINT#${e.id}`);
      continue;
    }

    // LINE: single segment to B (start A is in SRC for clarity)
    if (e.type === "LINE"){
      n++;
      lines.push(`${n},FEED_TO,${mmToU(e.B.x_mm).toFixed(d)},${mmToU(e.B.y_mm).toFixed(d)},,,${state.units},LINE#${e.id}:A(${mmToU(e.A.x_mm).toFixed(d)},${mmToU(e.A.y_mm).toFixed(d)})`);
      continue;
    }

    // POLYLINE: feed segments vertex-to-vertex; optionally close
    if (e.type === "POLYLINE"){
      if (!e.pts || e.pts.length < 2) continue;
      for (let i = 1; i < e.pts.length; i++){
        n++;
        lines.push(`${n},FEED_TO,${mmToU(e.pts[i].x_mm).toFixed(d)},${mmToU(e.pts[i].y_mm).toFixed(d)},,,${state.units},POLY#${e.id}:${i+1}`);
      }
      if (e.closed){
        n++;
        lines.push(`${n},FEED_TO,${mmToU(e.pts[0].x_mm).toFixed(d)},${mmToU(e.pts[0].y_mm).toFixed(d)},,,${state.units},POLY#${e.id}:CLOSE`);
      }
      continue;
    }

    // ARC3: derive center + direction, then emit one arc row with I,J from start.
    if (e.type === "ARC3"){
      const circ = circleFrom3(e.S, e.M, e.E);
      if (!circ) continue;
      const {cx, cy} = circ;

      const aS = angle(cx,cy,e.S.x_mm,e.S.y_mm);
      const aM = angle(cx,cy,e.M.x_mm,e.M.y_mm);
      const aE = angle(cx,cy,e.E.x_mm,e.E.y_mm);
      const sweepSE = mod2pi(aE - aS);
      const sweepSM = mod2pi(aM - aS);
      const ccw = (sweepSM <= sweepSE);

      const I = cx - e.S.x_mm;
      const J = cy - e.S.y_mm;
      const action = ccw ? "ARC_CCW_TO" : "ARC_CW_TO";
      n++;
      lines.push(`${n},${action},${mmToU(e.E.x_mm).toFixed(d)},${mmToU(e.E.y_mm).toFixed(d)},${mmToU(I).toFixed(d)},${mmToU(J).toFixed(d)},${state.units},ARC3#${e.id}`);
      continue;
    }

    // CIRCLE2: single semantic row (center + R)
    if (e.type === "CIRCLE2"){
      const r = Math.hypot(e.RP.x_mm - e.C.x_mm, e.RP.y_mm - e.C.y_mm);
      n++;
      lines.push(`${n},CIRCLE_CENTER_R,${mmToU(e.C.x_mm).toFixed(d)},${mmToU(e.C.y_mm).toFixed(d)},${mmToU(r).toFixed(d)},,${state.units},CIRCLE2#${e.id}`);
      continue;
    }
  }

  return lines.join("\n");
}

function updateLiveCSV(){
  const el = document.getElementById("csvLive");
  const status = document.getElementById("csvStatus");
  if (!el) return;

  const modeSel = document.getElementById("csvMode");
  const mode = modeSel ? modeSel.value : "waypoints";

  if (mode === "segments"){
    el.value = exportSegmentsCSV(activeFeature);
    if (status) status.textContent = `— Segments (CNC)`;
  } else {
    el.value = exportWaypointsCSV(activeFeature);
    if (status) status.textContent = `— Waypoints (${flattenFeaturePoints(activeFeature).length} rows)`;
  }
}




/* =========================
   Drawing
========================= */

function drawUnderlay(){
  if (!underlay.img) return;
  ctx.save();
  ctx.globalAlpha = underlay.opacity;

  // Compute world-space rectangle for the image, then map to screen-space
  const x0 = underlay.x_mm;
  const y0 = underlay.y_mm;
  const w_mm = underlay.img.width  * underlay.mmPerPx;
  const h_mm = underlay.img.height * underlay.mmPerPx;

  // Two opposite corners in world (image Y+ is down in pixels, but world Y+ is up)
  const c0 = w2s_world_mm(x0,        y0);
  const c1 = w2s_world_mm(x0 + w_mm, y0 - h_mm);

  // Canvas drawImage needs positive width/height; normalize
  const sx = Math.min(c0.sx, c1.sx);
  const sy = Math.min(c0.sy, c1.sy);
  const sw = Math.abs(c1.sx - c0.sx);
  const sh = Math.abs(c1.sy - c0.sy);

  // Guard against NaN/degenerate size
  if (!(sw > 0 && sh > 0)) { ctx.restore(); return; }

  ctx.drawImage(underlay.img, sx, sy, sw, sh);
  ctx.restore();
}


function drawGrid(){
  ctx.clearRect(0,0,cv.width,cv.height);
  drawUnderlay();


  const hasUnderlay = !!underlay.img;
  const GRID_MINOR = hasUnderlay ? 'rgba(0,0,0,0.18)' : '#ececec';
  const GRID_MAJOR = hasUnderlay ? 'rgba(0,0,0,0.28)' : '#c9c9c9';
  const AXIS_STROKE = hasUnderlay ? 'rgba(0,0,0,0.85)' : '#d00';
  const AXIS_WIDTH = hasUnderlay ? 2.2 : 1.6;
  const vw_mm = uToMM(state.viewWidth_u);
  const vh_mm = uToMM(viewHeight_u());
  const xmin_mm = state.center_world_mm.x - vw_mm/2;
  const xmax_mm = state.center_world_mm.x + vw_mm/2;
  const ymin_mm = state.center_world_mm.y - vh_mm/2;
  const ymax_mm = state.center_world_mm.y + vh_mm/2;

  const step_u = state.gridStep_u;
  const xmin_u = mmToU(xmin_mm);
  const ymin_u = mmToU(ymin_mm);
  const startX_u = Math.floor(xmin_u / step_u) * step_u;
  const startY_u = Math.floor(ymin_u / step_u) * step_u;

  for (let x_u = startX_u; x_u <= mmToU(xmax_mm) + step_u; x_u += step_u){
    const isMajor = (Math.round(x_u/step_u) % state.majorEvery) === 0;
    const x_mm = uToMM(x_u);
    const a = w2s_world_mm(x_mm, ymin_mm);
    const b = w2s_world_mm(x_mm, ymax_mm);
    ctx.beginPath();
    ctx.moveTo(a.sx, a.sy); ctx.lineTo(b.sx, b.sy);
    ctx.strokeStyle = isMajor ? GRID_MAJOR : GRID_MINOR;
    ctx.lineWidth = isMajor ? 1.2 : 1;
    ctx.stroke();
  }

  for (let y_u = startY_u; y_u <= mmToU(ymax_mm) + step_u; y_u += step_u){
    const isMajor = (Math.round(y_u/step_u) % state.majorEvery) === 0;
    const y_mm = uToMM(y_u);
    const a = w2s_world_mm(xmin_mm, y_mm);
    const b = w2s_world_mm(xmax_mm, y_mm);
    ctx.beginPath();
    ctx.moveTo(a.sx, a.sy); ctx.lineTo(b.sx, b.sy);
    ctx.strokeStyle = isMajor ? GRID_MAJOR : GRID_MINOR;
    ctx.lineWidth = isMajor ? 1.2 : 1;
    ctx.stroke();
  }

  {
    const z = w2s_world_mm(state.workZero_world_mm.x, state.workZero_world_mm.y);

    ctx.beginPath();
    ctx.moveTo(0, z.sy); ctx.lineTo(cv.width, z.sy);
    ctx.moveTo(z.sx, 0); ctx.lineTo(z.sx, cv.height);
    ctx.strokeStyle = AXIS_STROKE;
    ctx.lineWidth = AXIS_WIDTH;
    ctx.stroke();
    ctx.fillStyle = "#d00";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("X0,Y0", z.sx + 8, z.sy - 8);
  }

  ctx.fillStyle = "#222";
  ctx.font = "13px system-ui, sans-serif";
  ctx.fillText(`Units: ${state.units} | Feature: ${activeFeature} | Coord: ${state.coordFlavor}`, 10, 18);
}

function drawCrossAtWorld(xw, yw, size=6){
  const s = w2s_world_mm(xw, yw);
  ctx.beginPath();
  ctx.moveTo(s.sx-size, s.sy); ctx.lineTo(s.sx+size, s.sy);
  ctx.moveTo(s.sx, s.sy-size); ctx.lineTo(s.sx, s.sy+size);
  ctx.stroke();
}

function drawHoleMarkAtWorld(xw_mm, yw_mm, pxRadius){
  // DRILL marker: drafting-style crosshair only (symbolic; not a motion path).
  const s = w2s_world_mm(xw_mm, yw_mm);
  const r = pxRadius;
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(s.sx - r, s.sy); ctx.lineTo(s.sx + r, s.sy); // horizontal
  ctx.moveTo(s.sx, s.sy - r); ctx.lineTo(s.sx, s.sy + r); // vertical
  ctx.stroke();
  ctx.restore();
}


function drawDotAtWorld(xw, yw, r=3){
  const s = w2s_world_mm(xw, yw);
  ctx.beginPath();
  ctx.arc(s.sx, s.sy, r, 0, Math.PI*2);
  ctx.fill();
}

function drawXAtWorld(xw, yw, size=6){
  const s = w2s_world_mm(xw, yw);
  ctx.beginPath();
  ctx.moveTo(s.sx-size, s.sy-size); ctx.lineTo(s.sx+size, s.sy+size);
  ctx.moveTo(s.sx-size, s.sy+size); ctx.lineTo(s.sx+size, s.sy-size);
  ctx.stroke();
}

function drawCenterDotAtWorld(xw, yw, ring=6, dot=2){
  const s = w2s_world_mm(xw, yw);
  // ring
  ctx.beginPath();
  ctx.arc(s.sx, s.sy, ring, 0, Math.PI*2);
  ctx.stroke();
  // dot
  ctx.beginPath();
  ctx.arc(s.sx, s.sy, dot, 0, Math.PI*2);
  ctx.fill();
}

function drawEntities(){
  // Draw all features, but give active feature stronger stroke by ordering.
  const order = ["REF","POCKET","CONTOUR","DRILL"];
  // Put active last so it sits on top
  const ordered = order.filter(f=>f!==activeFeature).concat([activeFeature]);

  for (const f of ordered){
    const ents = getEntitiesForFeature(f);
    const isActive = (f===activeFeature);

    // simple styling by feature
    ctx.lineWidth = isActive ? 2.0 : 1.2;
    ctx.strokeStyle = (f==="DRILL") ? "#111" :
                      (f==="CONTOUR") ? "#333" :
                      (f==="POCKET") ? "#555" : "#777";
    ctx.fillStyle = "rgba(0,0,0,0)";

    for (const e of ents){
      if (e.type === "POINT"){
        const w = recToWorld_mm(e.p.x_mm, e.p.y_mm);
        // POINT is a datum/marker only (never tool motion).
        ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
        drawDotAtWorld(w.xw_mm, w.yw_mm, isActive ? 3 : 2);
      }
      if (e.type === "DRILL" || (e.type==="POINT" && f==="DRILL")){
        // Back-compat: older snapshots may store DRILL points as type POINT within feature DRILL.
        const p = e.p;
        const w = recToWorld_mm(p.x_mm, p.y_mm);
        drawHoleMarkAtWorld(w.xw_mm, w.yw_mm, isActive ? 7 : 6);
      }
      if (e.type === "LINE"){
        ctx.beginPath();
        const wA = recToWorld_mm(e.A.x_mm, e.A.y_mm);
        const wB = recToWorld_mm(e.B.x_mm, e.B.y_mm);
        const sA = w2s_world_mm(wA.xw_mm, wA.yw_mm);
        const sB = w2s_world_mm(wB.xw_mm, wB.yw_mm);
        ctx.moveTo(sA.sx, sA.sy);
        ctx.lineTo(sB.sx, sB.sy);
        ctx.stroke();

        // endpoints as breadcrumbs
        ctx.save();
        ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
        drawDotAtWorld(wA.xw_mm, wA.yw_mm, isActive ? 3 : 2);
        drawDotAtWorld(wB.xw_mm, wB.yw_mm, isActive ? 3 : 2);
        ctx.restore();
      }

      if (e.type === "POLYLINE"){
        if (e.pts.length < 2) continue;
        ctx.beginPath();
        const w0 = recToWorld_mm(e.pts[0].x_mm, e.pts[0].y_mm);
        const s0 = w2s_world_mm(w0.xw_mm, w0.yw_mm);
        ctx.moveTo(s0.sx, s0.sy);
        for (let i=1;i<e.pts.length;i++){
          const wi = recToWorld_mm(e.pts[i].x_mm, e.pts[i].y_mm);
          const si = w2s_world_mm(wi.xw_mm, wi.yw_mm);
          ctx.lineTo(si.sx, si.sy);
        }
        // Optional closure back to first point
        if (e.closed){
          const wEnd = recToWorld_mm(e.pts[0].x_mm, e.pts[0].y_mm);
          const sEnd = w2s_world_mm(wEnd.xw_mm, wEnd.yw_mm);
          ctx.lineTo(sEnd.sx, sEnd.sy);
        }
        ctx.stroke();
// vertex breadcrumbs (committed)
ctx.save();
ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
for (const p of e.pts){
  const wv = recToWorld_mm(p.x_mm, p.y_mm);
  drawDotAtWorld(wv.xw_mm, wv.yw_mm, isActive ? 3 : 2);
}
ctx.restore();
      }
      if (e.type === "ARC3"){
        const res = sampleArc3(e.S, e.M, e.E, Number(document.getElementById("sampleStep").value));
        if (!res) continue;
        ctx.beginPath();
        const w0 = recToWorld_mm(res.pts[0].x_mm, res.pts[0].y_mm);
        const s0 = w2s_world_mm(w0.xw_mm, w0.yw_mm);
        ctx.moveTo(s0.sx, s0.sy);
        for (let i=1;i<res.pts.length;i++){
          const wi = recToWorld_mm(res.pts[i].x_mm, res.pts[i].y_mm);
          const si = w2s_world_mm(wi.xw_mm, wi.yw_mm);
          ctx.lineTo(si.sx, si.sy);
        }
        ctx.stroke();
// defining breadcrumbs (S, M, E)
ctx.save();
ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
for (const p of [e.S, e.M, e.E]){
  const wv = recToWorld_mm(p.x_mm, p.y_mm);
  drawDotAtWorld(wv.xw_mm, wv.yw_mm, isActive ? 3 : 2);
}
ctx.restore();
      }
      if (e.type === "CIRCLE2"){
        const res = sampleCircle(e.C, e.RP, Number(document.getElementById("sampleStep").value));
        if (!res) continue;
        ctx.beginPath();
        const w0 = recToWorld_mm(res.pts[0].x_mm, res.pts[0].y_mm);
        const s0 = w2s_world_mm(w0.xw_mm, w0.yw_mm);
        ctx.moveTo(s0.sx, s0.sy);
        for (let i=1;i<res.pts.length;i++){
          const wi = recToWorld_mm(res.pts[i].x_mm, res.pts[i].y_mm);
          const si = w2s_world_mm(wi.xw_mm, wi.yw_mm);
          ctx.lineTo(si.sx, si.sy);
        }
        ctx.stroke();
// defining breadcrumbs (center as X, radius-point as dot)
ctx.save();
ctx.strokeStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
const wc = recToWorld_mm(e.C.x_mm, e.C.y_mm);
ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
        drawCenterDotAtWorld(wc.xw_mm, wc.yw_mm, isActive ? 6 : 5, isActive ? 2 : 2);
ctx.fillStyle = isActive ? "#000" : "rgba(0,0,0,0.35)";
const wrp = recToWorld_mm(e.RP.x_mm, e.RP.y_mm);
drawDotAtWorld(wrp.xw_mm, wrp.yw_mm, isActive ? 3 : 2);
ctx.restore();
      }
    }
  }
}


function drawToolOverlay(){
  // Temporary / in-progress geometry so you never "lose your place"
  ctx.save();
  ctx.lineWidth = 1.2;
  ctx.strokeStyle = "#000";
  ctx.fillStyle = "#000";

  const faint = (alpha)=>`rgba(0,0,0,${alpha})`;

    // LINE preview: start dot + dashed line to cursor, then commit on second click
  if (tool==="LINE" && lineTemp.length){
    const p0 = lineTemp[0];
    ctx.setLineDash([6,4]);
    const w0 = recToWorld_mm(p0.x_mm, p0.y_mm);
    drawDotAtWorld(w0.xw_mm, w0.yw_mm, 3);
    if (lastCursorRec){
      const wc = recToWorld_mm(lastCursorRec.x_mm, lastCursorRec.y_mm);
      const s0 = w2s_world_mm(w0.xw_mm, w0.yw_mm);
      const sc = w2s_world_mm(wc.xw_mm, wc.yw_mm);
      ctx.beginPath();
      ctx.moveTo(s0.sx, s0.sy);
      ctx.lineTo(sc.sx, sc.sy);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

// POLYLINE preview: vertices as dots + dashed lines, plus rubber-band to cursor
  if (tool==="POLYLINE" && polyTemp.length){
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    const w0 = recToWorld_mm(polyTemp[0].x_mm, polyTemp[0].y_mm);
    const s0 = w2s_world_mm(w0.xw_mm, w0.yw_mm);
    ctx.moveTo(s0.sx, s0.sy);

    for (let i=1;i<polyTemp.length;i++){
      const wi = recToWorld_mm(polyTemp[i].x_mm, polyTemp[i].y_mm);
      const si = w2s_world_mm(wi.xw_mm, wi.yw_mm);
      ctx.lineTo(si.sx, si.sy);
    }
    // rubber-band to cursor
    if (lastCursorRec){
      const wc = recToWorld_mm(lastCursorRec.x_mm, lastCursorRec.y_mm);
      const sc = w2s_world_mm(wc.xw_mm, wc.yw_mm);
      ctx.lineTo(sc.sx, sc.sy);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // vertices as solid dots (breadcrumbs)
    ctx.fillStyle = faint(0.9);
    for (const p of polyTemp){
      const w = recToWorld_mm(p.x_mm, p.y_mm);
      drawDotAtWorld(w.xw_mm, w.yw_mm, 3);
    }
  }

  // ARC3 preview: clicked points as X's, plus dashed guides, plus preview to cursor
  if (tool==="ARC3" && arcTemp.length){
    ctx.strokeStyle = faint(0.95);
    ctx.setLineDash([]);

    // clicked points as X's
    for (const p of arcTemp){
      const w = recToWorld_mm(p.x_mm, p.y_mm);
      drawXAtWorld(w.xw_mm, w.yw_mm, 6);
    }

    // guide lines
    ctx.setLineDash([6,4]);
    if (arcTemp.length >= 2){
      const a = recToWorld_mm(arcTemp[0].x_mm, arcTemp[0].y_mm);
      const b = recToWorld_mm(arcTemp[1].x_mm, arcTemp[1].y_mm);
      const sa = w2s_world_mm(a.xw_mm, a.yw_mm);
      const sb = w2s_world_mm(b.xw_mm, b.yw_mm);
      ctx.beginPath();
      ctx.moveTo(sa.sx, sa.sy);
      ctx.lineTo(sb.sx, sb.sy);

      // preview from mid to cursor as you place the 3rd point
      if (arcTemp.length === 2 && lastCursorRec){
        const c = recToWorld_mm(lastCursorRec.x_mm, lastCursorRec.y_mm);
        const sc = w2s_world_mm(c.xw_mm, c.yw_mm);
        ctx.lineTo(sc.sx, sc.sy);
      }
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // CIRCLE2 preview: center as X, radius point as X when chosen, plus dashed radius + dashed circle
  if (tool==="CIRCLE2" && circTemp.length){
    ctx.strokeStyle = faint(0.95);
    ctx.setLineDash([]);

    // center is always the first point
    const c0 = circTemp[0];
    const wc0 = recToWorld_mm(c0.x_mm, c0.y_mm);
    drawXAtWorld(wc0.xw_mm, wc0.yw_mm, 7);

    // If we don't have radius point yet, use cursor for preview
    let rp = null;
    if (circTemp.length >= 2){
      rp = circTemp[1];
      const wrp = recToWorld_mm(rp.x_mm, rp.y_mm);
      drawXAtWorld(wrp.xw_mm, wrp.yw_mm, 6);
    } else if (lastCursorRec){
      rp = {x_mm:lastCursorRec.x_mm, y_mm:lastCursorRec.y_mm};
    }

    if (rp){
      // radius line
      ctx.setLineDash([6,4]);
      const wrp = recToWorld_mm(rp.x_mm, rp.y_mm);
      const sc = w2s_world_mm(wc0.xw_mm, wc0.yw_mm);
      const sr = w2s_world_mm(wrp.xw_mm, wrp.yw_mm);
      ctx.beginPath();
      ctx.moveTo(sc.sx, sc.sy);
      ctx.lineTo(sr.sx, sr.sy);
      ctx.stroke();

      // dashed circle outline preview
      const r_mm = Math.hypot(rp.x_mm - c0.x_mm, rp.y_mm - c0.y_mm);
      const n = 90;
      ctx.beginPath();
      for (let i=0;i<=n;i++){
        const t = (i/n)*Math.PI*2;
        const x_mm = c0.x_mm + r_mm*Math.cos(t);
        const y_mm = c0.y_mm + r_mm*Math.sin(t);
        const w = recToWorld_mm(x_mm, y_mm);
        const s = w2s_world_mm(w.xw_mm, w.yw_mm);
        if (i===0) ctx.moveTo(s.sx, s.sy); else ctx.lineTo(s.sx, s.sy);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }


  // RECT2 preview: anchor corner as X, opposite corner uses second click or cursor, dashed rectangle outline
  if (tool==="RECT2" && rectTemp.length){
    ctx.strokeStyle = faint(0.95);
    ctx.setLineDash([]);

    const a0 = rectTemp[0];
    const wa0 = recToWorld_mm(a0.x_mm, a0.y_mm);
    drawXAtWorld(wa0.xw_mm, wa0.yw_mm, 7);

    let b = null;
    if (rectTemp.length >= 2){
      b = rectTemp[1];
      const wb = recToWorld_mm(b.x_mm, b.y_mm);
      drawXAtWorld(wb.xw_mm, wb.yw_mm, 6);
    } else if (lastCursorRec){
      b = {x_mm:lastCursorRec.x_mm, y_mm:lastCursorRec.y_mm};
    }

    if (b){
      const xmin = Math.min(a0.x_mm, b.x_mm), xmax = Math.max(a0.x_mm, b.x_mm);
      const ymin = Math.min(a0.y_mm, b.y_mm), ymax = Math.max(a0.y_mm, b.y_mm);

      const p1 = recToWorld_mm(xmin, ymin);
      const p2 = recToWorld_mm(xmax, ymin);
      const p3 = recToWorld_mm(xmax, ymax);
      const p4 = recToWorld_mm(xmin, ymax);

      const s1 = w2s_world_mm(p1.xw_mm, p1.yw_mm);
      const s2p = w2s_world_mm(p2.xw_mm, p2.yw_mm);
      const s3 = w2s_world_mm(p3.xw_mm, p3.yw_mm);
      const s4 = w2s_world_mm(p4.xw_mm, p4.yw_mm);

      ctx.setLineDash([6,4]);
      ctx.beginPath();
      ctx.moveTo(s1.sx, s1.sy);
      ctx.lineTo(s2p.sx, s2p.sy);
      ctx.lineTo(s3.sx, s3.sy);
      ctx.lineTo(s4.sx, s4.sy);
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }


  ctx.restore();
}


function redraw(){
  drawGrid();
  drawEntities();
  drawToolOverlay();
  refreshUI();
  updateLiveCSV();
}

/* =========================
   UI tables
========================= */
const elEntCount = document.getElementById("entCount");
const elPtCount  = document.getElementById("ptCount");
const elEntTable = document.getElementById("entTable");
const elPtTable  = document.getElementById("ptTable");

function summarizeEntity(e){
  const d = U[state.units].decimals;
  const fmt = v=>mmToU(v).toFixed(d);

  if (e.type==="POINT"){
    return `X${fmt(e.p.x_mm)} Y${fmt(e.p.y_mm)}`;
  }
  if (e.type==="DRILL"){
    return `DRILL X${fmt(e.p.x_mm)} Y${fmt(e.p.y_mm)}`;
  }
  if (e.type==="POLYLINE"){
    return `${e.pts.length} vertices`;
  }
  if (e.type==="ARC3"){
    return `3pt arc`;
  }
  if (e.type==="CIRCLE2"){
    const r = Math.hypot(e.RP.x_mm - e.C.x_mm, e.RP.y_mm - e.C.y_mm);
    return `R${fmt(r)}`;
  }
  return "";
}

function refreshUI(){
  const _fh = document.getElementById("featureHint");
  if (_fh) _fh.textContent = featureHints[activeFeature];

// Derived points panel visibility (keeps "truth points" less confusing)
const showDerived = document.getElementById("showDerived");
const ptWrap = document.getElementById("ptTableWrap");
if (showDerived && ptWrap){
  ptWrap.style.display = showDerived.checked ? "block" : "none";
}

  const ents = getEntitiesForFeature(activeFeature);
  elEntCount.textContent = String(ents.length);

  // Entities table (Patch B: selectable rows + ⋮ affordance)
  let ehtml = "";
  ents.forEach((e,idx)=>{
    ehtml += `<tr class="entityRow" data-eid="${e.id}">
      <td>${idx+1}</td>
      <td>${e.type}</td>
      <td>${summarizeEntity(e)}</td>
      <td>
        <button class="dots" type="button" data-menu="${e.id}">⋮</button>
        <button class="btn" type="button" data-del="${e.id}">Delete</button>
      </td>
    </tr>`;
  });
  elEntTable.innerHTML = ehtml;

  // Step 3: selection highlight (reveals ⋮)
  elEntTable.querySelectorAll("tr.entityRow").forEach(tr=>{
    tr.addEventListener("click", (ev)=>{
      if (ev.target && ev.target.closest("button")) return;
      elEntTable.querySelectorAll("tr.entityRow.selected").forEach(n=>n.classList.remove("selected"));
      tr.classList.add("selected");
    });
  });

  // ⋮ menu stub (UX eval; wire real actions later)
  elEntTable.querySelectorAll("button[data-menu]").forEach(btn=>{
    btn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      const id = Number(btn.dataset.menu);
      alert(`Actions for entity #${id} (stub)`);
    });
  });

  // Delete wiring
  elEntTable.querySelectorAll("button[data-del]").forEach(btn=>{
    btn.addEventListener("click", (ev)=>{
      ev.stopPropagation();
      deleteEntity(Number(btn.dataset.del));
      redraw();
    });
  });

// Points table (flattened)
  const pts = flattenFeaturePoints(activeFeature);
  elPtCount.textContent = String(pts.length);
  const d = U[state.units].decimals;

  let phtml = "";
  pts.forEach((p,i)=>{
    const x = mmToU(p.x_mm).toFixed(d);
    const y = mmToU(p.y_mm).toFixed(d);
    if (p.editable){
      phtml += `<tr data-ent="${p.entId}">
        <td>${i+1}</td>
        <td class="r"><input class="px" type="number" step="0.001" value="${x}"></td>
        <td class="r"><input class="py" type="number" step="0.001" value="${y}"></td>
        <td>${p.src}</td>
      </tr>`;
    } else {
      phtml += `<tr>
        <td>${i+1}</td><td class="r">${x}</td><td class="r">${y}</td><td>${p.src}</td>
      </tr>`;
    }
  });
  elPtTable.innerHTML = phtml;

  // Live editing only for POINT entities (clean + maintainable)
  elPtTable.querySelectorAll("tr[data-ent]").forEach(tr=>{
    const entId = Number(tr.dataset.ent);
    const xIn = tr.querySelector(".px");
    const yIn = tr.querySelector(".py");
    function commit(){
      const x_u = Number(xIn.value);
      const y_u = Number(yIn.value);
      if (!Number.isFinite(x_u) || !Number.isFinite(y_u)) return;
      const e = entities.find(e=>e.id===entId);
      if (!e || e.type!=="POINT") return;
      e.p.x_mm = uToMM(x_u);
      e.p.y_mm = uToMM(y_u);
      redraw();
    }
    xIn.addEventListener("change", commit);
    yIn.addEventListener("change", commit);
  });
}

/* =========================
   Tooling
========================= */
let tool = "POINT";
let zeroPickMode = false;


const btnPoint   = document.getElementById("toolPoint");
const btnDrill   = document.getElementById("toolDrill");
const btnLine    = document.getElementById("toolLine");
const btnPoly    = document.getElementById("toolPolyline");
const btnArc3    = document.getElementById("toolArc3");
const btnCircle2 = document.getElementById("toolCircle2");
const btnRect2   = document.getElementById("toolRect2");

const TOOL_MEANING = {
  POINT:    "POINT — click to add a reference marker. (No tool motion in exports.)",
  DRILL:    "DRILL — click to add a hole location (symbolic for now; machining later with Z strategy).",
  LINE:     "LINE — click Start → End to create a LINE entity (motion in exports).",
  POLYLINE: "POLYLINE — click vertices; Enter or Double‑click to finish; Esc cancels. Use Closed to close back to the first point.",
  ARC3:     "ARC (3pt) — click Start → Mid → End to create a 3‑point arc (motion in exports).",
  CIRCLE2:  "CIRCLE — click Center → Radius point to create a circle (emits arcs in exports).",
  RECT2:    "RECTANGLE — click corner → opposite corner to create an axis‑aligned closed polyline (motion in exports)."
};
const TOOL_GLOBAL_HINT = "Tip: hold Shift to disable snap for one click.";




function setTool(t){
  tool = t;
  setToolMeaning(TOOL_MEANING[t] || "—");
  [btnPoint,btnDrill,btnLine,btnPoly,btnArc3,btnCircle2,btnRect2].forEach(b=>b.classList.remove("on"));
  ({POINT:btnPoint, DRILL:btnDrill, LINE:btnLine, POLYLINE:btnPoly, ARC3:btnArc3, CIRCLE2:btnCircle2, RECT2:btnRect2}[t]).classList.add("on");
  setPolyClosedUIEnabled(t==="POLYLINE");
  if (t==="POLYLINE") syncPolyClosedDefault();
  polyTemp = [];
  lineTemp = [];
  arcTemp = [];
  circTemp = [];
  rectTemp = [];
  redraw();
}

btnPoint.onclick = ()=>setTool("POINT");
btnDrill.onclick = ()=>setTool("DRILL");
btnLine.onclick = ()=>setTool("LINE");
btnPoly.onclick = ()=>setTool("POLYLINE");
btnArc3.onclick = ()=>setTool("ARC3");
btnCircle2.onclick = ()=>setTool("CIRCLE2");
btnRect2.onclick = ()=>setTool("RECT2");

setToolMeaning(TOOL_MEANING[tool] || "—");


// =========================
// Underlay UI bindings
// =========================
const elUnderlayFile    = document.getElementById("underlayFile");
const elUnderlayClear   = document.getElementById("underlayClear");
const elUnderlayLock    = document.getElementById("underlayLock");
const elUnderlayOpacity = document.getElementById("underlayOpacity");
const elUnderlayScale   = document.getElementById("underlayScale");
const elUnderlayX       = document.getElementById("underlayX");
const elUnderlayY       = document.getElementById("underlayY");
const elUnderlayToCursor= document.getElementById("underlayToCursor");
const elUnderlayReset   = document.getElementById("underlayReset");


const elUnderlayFit     = document.getElementById("underlayFit");
const elUnderlayW       = document.getElementById("underlayW");
const elUnderlayH       = document.getElementById("underlayH");
const elUnderlayApplySz = document.getElementById("underlayApplySize");
function syncUnderlayInputs(){
  if (!elUnderlayOpacity) return;
  elUnderlayOpacity.value = String(underlay.opacity);

  const sc = Number.isFinite(underlay.mmPerPx) ? underlay.mmPerPx : 1.0;
  elUnderlayScale.value = String(sc.toFixed(2));

  const d = U[state.units].decimals;
  const xU = Number.isFinite(underlay.x_mm) ? mmToU(underlay.x_mm) : 0;
  const yU = Number.isFinite(underlay.y_mm) ? mmToU(underlay.y_mm) : 0;
  elUnderlayX.value = String(xU.toFixed(d));
  elUnderlayY.value = String(yU.toFixed(d));

  elUnderlayLock.checked = !!underlay.locked;
}

function readUnderlayInputsToState(){
  if (!elUnderlayOpacity) return;

  // NaN-safe reads: ignore invalid input and keep last-good state
  const op = Number(elUnderlayOpacity.value);
  if (Number.isFinite(op)) underlay.opacity = Math.min(1, Math.max(0, op));

  const sc = Number(elUnderlayScale.value);
  if (Number.isFinite(sc) && sc>0) underlay.mmPerPx = Math.max(0.0001, sc);

  const xU = Number(elUnderlayX.value);
  if (Number.isFinite(xU)) underlay.x_mm = uToMM(xU);

  const yU = Number(elUnderlayY.value);
  if (Number.isFinite(yU)) underlay.y_mm = uToMM(yU);

  underlay.locked = !!elUnderlayLock.checked;
}

function fitUnderlayToView(){
  if (!underlay.img) return;
  const vw_mm = uToMM(state.viewWidth_u);
  const vh_mm = uToMM(viewHeight_u());
  const imgW = underlay.img.width;
  const imgH = underlay.img.height;
  const mmPerPx = Math.max(0.0001, Math.min(vw_mm / imgW, vh_mm / imgH));
  underlay.mmPerPx = mmPerPx;

  // Center image in view
  const cx = state.center_world_mm.x;
  const cy = state.center_world_mm.y;
  const w_mm = imgW * mmPerPx;
  const h_mm = imgH * mmPerPx;
  underlay.x_mm = cx - w_mm/2;
  underlay.y_mm = cy + h_mm/2; // top-left y

  syncUnderlayInputs();
  redraw();
}

function applyUnderlaySize(){
  if (!underlay.img) return;
  const wU = elUnderlayW ? Number(elUnderlayW.value) : NaN;
  const hU = elUnderlayH ? Number(elUnderlayH.value) : NaN;
  const imgW = underlay.img.width;
  const imgH = underlay.img.height;

  let mmPerPx = NaN;
  if (Number.isFinite(wU) && wU > 0){
    mmPerPx = uToMM(wU) / imgW;
  }
  if (Number.isFinite(hU) && hU > 0){
    const mmPerPxH = uToMM(hU) / imgH;
    mmPerPx = Number.isFinite(mmPerPx) ? Math.min(mmPerPx, mmPerPxH) : mmPerPxH;
  }
  if (!Number.isFinite(mmPerPx) || mmPerPx <= 0) return;

  underlay.mmPerPx = Math.max(0.0001, mmPerPx);
  syncUnderlayInputs();
  redraw();
}

// Underlay drag (Alt-drag while unlocked)
let underlayDrag = null;
function beginUnderlayDrag(sx, sy){
  underlayDrag = {sx0:sx, sy0:sy, x0:underlay.x_mm, y0:underlay.y_mm};
}
function updateUnderlayDrag(sx, sy){
  if (!underlayDrag) return;
  // Convert screen delta to world delta
  const w0 = s2w_world_mm(underlayDrag.sx0, underlayDrag.sy0);
  const w1 = s2w_world_mm(sx, sy);
  const dx = w1.x_mm - w0.x_mm;
  const dy = w1.y_mm - w0.y_mm;
  underlay.x_mm = underlayDrag.x0 + dx;
  underlay.y_mm = underlayDrag.y0 + dy;
  syncUnderlayInputs();
  redraw();
}
function endUnderlayDrag(){
  underlayDrag = null;
}

if (elUnderlayFile){
  elUnderlayFile.addEventListener("change", ()=>{
    const f = elUnderlayFile.files && elUnderlayFile.files[0];
    if (!f) return;

    const reader = new FileReader();
    reader.onload = ()=>{
      const dataUrl = String(reader.result || "");
      if (!dataUrl) return;

      const img = new Image();
      img.onload = ()=>{
        underlay.img = img;
        underlay.dataUrl = dataUrl;
        underlay.name = f.name || null;
        underlay.mime = f.type || null;

        // Default placement: top-left at current cursor (snapped) if available, else at work zero
        const base = (lastCursorWorld ? {x_mm:lastCursorWorld.x_mm, y_mm:lastCursorWorld.y_mm} : state.workZero_world_mm);
        underlay.x_mm = base.x_mm;
        underlay.y_mm = base.y_mm;
        syncUnderlayInputs();
        redraw();
      };
      img.src = dataUrl;
    };
    reader.readAsDataURL(f);
  });
}
if (elUnderlayClear){
  elUnderlayClear.addEventListener("click", ()=>{
    underlay.img = null;
    redraw();
  });
}
[elUnderlayLock, elUnderlayOpacity, elUnderlayScale, elUnderlayX, elUnderlayY].forEach(el=>{
  if (!el) return;
  el.addEventListener("input", ()=>{
    readUnderlayInputsToState();
    redraw();
  });
});
if (elUnderlayToCursor){
  elUnderlayToCursor.addEventListener("click", ()=>{
    if (!lastCursorWorld) return;
    underlay.x_mm = lastCursorWorld.x_mm;
    underlay.y_mm = lastCursorWorld.y_mm;
    syncUnderlayInputs();
    redraw();
  });
}
if (elUnderlayReset){
  elUnderlayReset.addEventListener("click", ()=>{
    underlay.opacity = 0.45;
    underlay.mmPerPx = 1.0;
    underlay.locked = true;
    const base = (lastCursorWorld ? {x_mm:lastCursorWorld.x_mm, y_mm:lastCursorWorld.y_mm} : state.workZero_world_mm);
    underlay.x_mm = base.x_mm;
    underlay.y_mm = base.y_mm;
    syncUnderlayInputs();
    redraw();
  });

}

if (elUnderlayFit){
  elUnderlayFit.addEventListener("click", ()=>{
    readUnderlayInputsToState();
    fitUnderlayToView();
  });
}
if (elUnderlayApplySz){
  elUnderlayApplySz.addEventListener("click", ()=>{
    readUnderlayInputsToState();
    applyUnderlaySize();
  });
}

syncUnderlayInputs();

// =========================
// Geometry generators

// =========================
function regularVertices_mm(cx_mm, cy_mm, r_mm, n, startDeg){
  const a0 = (startDeg||0) * Math.PI/180;
  const pts = [];
  for (let i=0;i<n;i++){
    const a = a0 + i*(2*Math.PI/n);
    pts.push({x_mm: cx_mm + r_mm*Math.cos(a), y_mm: cy_mm + r_mm*Math.sin(a)});
  }
  return pts;
}

function addPolylineEntity(pts, closed=true){
  addEntity({feature:"CONTOUR", type:"POLYLINE", pts: pts.slice(), closed: !!closed});
}

function addDrillEntities(pts){
  pts.forEach(p=> addEntity({feature:"DRILL", type:"DRILL", p:{x_mm:p.x_mm, y_mm:p.y_mm}}));
}

const elNgonSides = document.getElementById("ngonSides");
const elNgonRadius= document.getElementById("ngonRadius");
const elNgonStart = document.getElementById("ngonStartDeg");
const elNgonCx    = document.getElementById("ngonCx");
const elNgonCy    = document.getElementById("ngonCy");
const elNgonPoly  = document.getElementById("ngonAsPolyline");
const elNgonDrill = document.getElementById("ngonAsDrills");
const btnNgonCenter = document.getElementById("ngonCenterFromCursor");
const btnNgonMake   = document.getElementById("ngonMake");

function setNgonCenterFromCursor(){
  if (!lastCursorWorld) return;
  elNgonCx.value = mmToU(lastCursorWorld.x_mm).toFixed(U[state.units].decimals);
  elNgonCy.value = mmToU(lastCursorWorld.y_mm).toFixed(U[state.units].decimals);
}
if (btnNgonCenter) btnNgonCenter.addEventListener("click", ()=>{ setNgonCenterFromCursor(); });

if (btnNgonMake){
  btnNgonMake.addEventListener("click", ()=>{
    const n = Math.max(3, Math.floor(Number(elNgonSides.value)||3));
    const r_mm = uToMM(Number(elNgonRadius.value)||0);
    const cx_mm = uToMM(Number(elNgonCx.value)||0);
    const cy_mm = uToMM(Number(elNgonCy.value)||0);
    const start = Number(elNgonStart.value)||0;
    const pts = regularVertices_mm(cx_mm, cy_mm, r_mm, n, start);
    if (elNgonPoly && elNgonPoly.checked) addPolylineEntity(pts, true);
    if (elNgonDrill && elNgonDrill.checked) addDrillEntities(pts);
    redraw();
  });
}

const elSubDiv   = document.getElementById("subDiv");
const elSubRadius= document.getElementById("subRadius");
const elSubStart = document.getElementById("subStartDeg");
const elSubCx    = document.getElementById("subCx");
const elSubCy    = document.getElementById("subCy");
const elSubDrill = document.getElementById("subAsDrills");
const elSubPoly  = document.getElementById("subAsPolygon");
const btnSubCenter= document.getElementById("subCenterFromCursor");
const btnSubMake  = document.getElementById("subMake");

function setSubCenterFromCursor(){
  if (!lastCursorWorld) return;
  elSubCx.value = mmToU(lastCursorWorld.x_mm).toFixed(U[state.units].decimals);
  elSubCy.value = mmToU(lastCursorWorld.y_mm).toFixed(U[state.units].decimals);
}
if (btnSubCenter) btnSubCenter.addEventListener("click", ()=>{ setSubCenterFromCursor(); });

if (btnSubMake){
  btnSubMake.addEventListener("click", ()=>{
    const n = Math.max(3, Math.floor(Number(elSubDiv.value)||3));
    const r_mm = uToMM(Number(elSubRadius.value)||0);
    const cx_mm = uToMM(Number(elSubCx.value)||0);
    const cy_mm = uToMM(Number(elSubCy.value)||0);
    const start = Number(elSubStart.value)||0;
    const pts = regularVertices_mm(cx_mm, cy_mm, r_mm, n, start);
    if (elSubDrill && elSubDrill.checked) addDrillEntities(pts);
    if (elSubPoly && elSubPoly.checked) addPolylineEntity(pts, true);
    redraw();
  });
}




let polyTemp = [];
let lineTemp = [];
let arcTemp = [];
let circTemp = [];
let rectTemp = [];
const elPolyClosed = document.getElementById("polyClosed");
function setPolyClosedUIEnabled(enabled){
  if (!elPolyClosed) return;
  const lab = elPolyClosed.closest("label");
  if (lab) lab.style.opacity = enabled ? "1" : "0.45";
  elPolyClosed.disabled = !enabled;
}
function syncPolyClosedDefault(){
  if (!elPolyClosed) return;
  // Default: POCKET tends to be closed, CONTOUR tends to be open.
  elPolyClosed.checked = (activeFeature === "POCKET");
}


// keyboard: finish polyline

window.addEventListener("keydown", (e)=>{
  // Undo/Redo shortcuts
  const isMac = navigator.platform.toUpperCase().includes("MAC");
  const mod = isMac ? e.metaKey : e.ctrlKey;

  if (mod && !e.shiftKey && (e.key === "z" || e.key === "Z")){
    e.preventDefault();
    doUndo();
    return;
  }
  if ((mod && (e.key === "y" || e.key === "Y")) || (mod && e.shiftKey && (e.key === "z" || e.key === "Z"))){
    e.preventDefault();
    doRedo();
    return;
  }

  // keyboard: finish/cancel polyline
  if (tool==="POLYLINE"){
    if (e.key === "Enter"){
      if (polyTemp.length >= 2){
        addEntity({feature:activeFeature, type:"POLYLINE", pts: polyTemp.map(p=>({...p})), closed: (elPolyClosed ? elPolyClosed.checked : (activeFeature==="POCKET"))});
      }
      polyTemp = [];
      redraw();
    }
    if (e.key === "Escape"){
      polyTemp = [];
      redraw();
    }
  }
});


let lastCursorRec = null;
let lastCursorWorld = null;

const elReadout = document.getElementById("readout");
cv.addEventListener("mousedown", (e)=>{
  const r = cv.getBoundingClientRect();
  const sx = e.clientX - r.left;
  const sy = e.clientY - r.top;

  // Alt-drag underlay when unlocked
  if (e.altKey && underlay.img && !underlay.locked){
    beginUnderlayDrag(sx, sy);
    e.preventDefault();
    return;
  }
});

cv.addEventListener("mouseup", (e)=>{
  if (underlayDrag){ endUnderlayDrag(); e.preventDefault(); return; }
});

cv.addEventListener("mouseleave", (e)=>{
  if (underlayDrag){ endUnderlayDrag(); }
});

cv.addEventListener("mousemove", (e)=>{
  const r = cv.getBoundingClientRect();
  const sx = e.clientX - r.left;
  const sy = e.clientY - r.top;

  if (underlayDrag){
    updateUnderlayDrag(sx, sy);
    return;
  }
  const w = s2w_world_mm(sx, sy);

  const snapEnabled = document.getElementById("snap").checked && !e.shiftKey;
  let rec = worldToRec_mm(w.x_mm, w.y_mm);
  rec = snapRec(rec, snapEnabled);

  lastCursorRec = rec;
  // Store a matching world point (snapped) for overlays
  const wsn = recToWorld_mm(rec.x_mm, rec.y_mm);
  lastCursorWorld = {x_mm: wsn.xw_mm, y_mm: wsn.yw_mm};

  const d = U[state.units].decimals;
  elReadout.textContent =
    `Cursor: X ${mmToU(rec.x_mm).toFixed(d)} ${state.units}  Y ${mmToU(rec.y_mm).toFixed(d)} ${state.units}` +
    (zeroPickMode ? "  (pick X0,Y0)" : "");

  // Redraw only if a tool is mid-construction (for rubber-band previews)
  if (tool==="POLYLINE" || tool==="ARC3" || tool==="CIRCLE2" || tool==="RECT2"){
    if (polyTemp.length || arcTemp.length || circTemp.length || rectTemp.length){
      redraw();
    }
  }
});

// Clear rubber-band previews when the cursor leaves the canvas
cv.addEventListener("mouseleave", ()=>{
  lastCursorRec = null;
  lastCursorWorld = null;
  // Only redraw if a tool is mid-construction
  if ((tool==="POLYLINE" && polyTemp.length) || (tool==="ARC3" && arcTemp.length) || (tool==="CIRCLE2" && circTemp.length) || (tool==="RECT2" && rectTemp.length)){
    redraw();
  }
});


// Finish polyline quickly
cv.addEventListener("dblclick", (e)=>{
  if (tool !== "POLYLINE") return;
  e.preventDefault();
  if (polyTemp.length >= 2){
    addEntity({feature:activeFeature, type:"POLYLINE", pts: polyTemp.map(p=>({...p})), closed: (elPolyClosed ? elPolyClosed.checked : (activeFeature==="POCKET"))});
  }
  polyTemp = [];
  redraw();
});



cv.addEventListener("click", (e)=>{
  const r = cv.getBoundingClientRect();
  const sx = e.clientX - r.left;
  const sy = e.clientY - r.top;

  const world = s2w_world_mm(sx, sy);

  if (zeroPickMode){
    state.workZero_world_mm = {x: world.x_mm, y: world.y_mm};
    document.getElementById("x0").value = mmToU(state.workZero_world_mm.x).toFixed(U[state.units].decimals);
    document.getElementById("y0").value = mmToU(state.workZero_world_mm.y).toFixed(U[state.units].decimals);
    zeroPickMode = false;
    redraw();
    return;
  }

  const snapEnabled = document.getElementById("snap").checked && !e.shiftKey;
  let rec = worldToRec_mm(world.x_mm, world.y_mm);
  rec = snapRec(rec, snapEnabled);

  if (tool==="POINT"){
    addEntity({feature:"REF", type:"POINT", p:{x_mm:rec.x_mm, y_mm:rec.y_mm}});
    redraw();
    return;
  }

  if (tool==="DRILL"){
    addEntity({feature:"DRILL", type:"DRILL", p:{x_mm:rec.x_mm, y_mm:rec.y_mm}});
    redraw();
    return;
  }

  if (tool==="LINE"){
    if (lineTemp.length === 0){
      lineTemp = [{x_mm:rec.x_mm, y_mm:rec.y_mm}];
    } else {
      addEntity({feature:activeFeature, type:"LINE", A: lineTemp[0], B:{x_mm:rec.x_mm, y_mm:rec.y_mm}});
      lineTemp = [];
    }
    redraw();
    return;
  }

  if (tool==="POLYLINE"){
    polyTemp.push({x_mm:rec.x_mm, y_mm:rec.y_mm});
    // Temp preview handled by drawToolOverlay()
    redraw();
    return;
  }

  if (tool==="ARC3"){
    arcTemp.push({x_mm:rec.x_mm, y_mm:rec.y_mm});
    if (arcTemp.length===3){
      addEntity({feature:activeFeature, type:"ARC3", S:arcTemp[0], M:arcTemp[1], E:arcTemp[2]});
      arcTemp = [];
    }
    redraw();
    return;
  }

  if (tool==="CIRCLE2"){
    circTemp.push({x_mm:rec.x_mm, y_mm:rec.y_mm});
    if (circTemp.length===2){
      addEntity({feature:activeFeature, type:"CIRCLE2", C:circTemp[0], RP:circTemp[1]});
      circTemp = [];
    }
    redraw();
    return;
  }

  if (tool==="RECT2"){
    rectTemp.push({x_mm:rec.x_mm, y_mm:rec.y_mm});
    if (rectTemp.length===2){
      const a = rectTemp[0];
      const b = rectTemp[1];
      const xmin = Math.min(a.x_mm,b.x_mm), xmax = Math.max(a.x_mm,b.x_mm);
      const ymin = Math.min(a.y_mm,b.y_mm), ymax = Math.max(a.y_mm,b.y_mm);
      const pts = [
        {x_mm:xmin, y_mm:ymin},
        {x_mm:xmax, y_mm:ymin},
        {x_mm:xmax, y_mm:ymax},
        {x_mm:xmin, y_mm:ymax}
      ];
      addEntity({feature:activeFeature, type:"POLYLINE", pts, closed:true});
      rectTemp = [];
    }
    redraw();
    return;
  }

});


function getExportScope(){
  const el = document.getElementById("exportScope");
  return el ? el.value : "all";
}

function isSketchExportEnabled(){
  const el = document.getElementById("sketchExport");
  return el ? !!el.checked : true; // default whole-sketch behavior
}

/* =========================
   Controls
========================= */
const elFeature = document.getElementById("feature");
if (elFeature) elFeature.addEventListener("change", (e)=>{
  activeFeature = e.target.value;
  // If you are about to start a polyline, default closure based on feature intent
  if (tool==="POLYLINE" && polyTemp.length===0) syncPolyClosedDefault();
  redraw();
});

// CSV mode affects only the Live CSV pane
const csvModeSel = document.getElementById("csvMode");
if (csvModeSel){
  csvModeSel.addEventListener("change", ()=> updateLiveCSV());
}

// Flattened/derived points table visibility
const showDerivedSel = document.getElementById("showDerived");
if (showDerivedSel){
  showDerivedSel.addEventListener("change", ()=> refreshUI());
}


document.getElementById("apply").addEventListener("click", ()=>{
  state.units = document.getElementById("units").value;
  state.gridStep_u = Number(document.getElementById("gridStep").value);
  state.majorEvery = Math.max(1, Math.floor(Number(document.getElementById("majorEvery").value)));
  state.viewWidth_u = Number(document.getElementById("viewWidth").value);
  state.coordFlavor = document.getElementById("coordFlavor").value;
  redraw();
});

document.getElementById("setZero").addEventListener("click", ()=>{
  state.workZero_world_mm = { x: uToMM(Number(document.getElementById("x0").value)),
                             y: uToMM(Number(document.getElementById("y0").value)) };
  redraw();
});

document.getElementById("pickZero").addEventListener("click", ()=>{
  zeroPickMode = true;
  redraw();
});

const DEFAULT_VIEW_WIDTH_U = state.viewWidth_u;

const elCenterViewZero = document.getElementById("centerViewZero");
if (elCenterViewZero){
  elCenterViewZero.addEventListener("click", ()=>{
    state.center_world_mm = {x: state.workZero_world_mm.x, y: state.workZero_world_mm.y};
    redraw();
  });
}
const elResetView = document.getElementById("resetView");
if (elResetView){
  elResetView.addEventListener("click", ()=>{
    state.center_world_mm = {x: 0, y: 0};
    state.viewWidth_u = DEFAULT_VIEW_WIDTH_U;
    redraw();
  });
}

function doUndo(){
  // Tool-local undo while constructing
  if (tool==="POLYLINE" && polyTemp.length){ polyTemp.pop(); redraw(); return; }
  if (tool==="LINE" && lineTemp.length){ lineTemp.pop(); redraw(); return; }
  if (tool==="ARC3" && arcTemp.length){ arcTemp.pop(); redraw(); return; }
  if (tool==="CIRCLE2" && circTemp.length){ circTemp.pop(); redraw(); return; }

  if (!canUndo()) return;
  const snap = undoStack.pop();
  redoStack.push(snapshotState());
  restoreSnapshot(snap);
}

function doRedo(){
  // Tool-local redo not implemented yet (kept simple)
  if (!canRedo()) return;
  const snap = redoStack.pop();
  undoStack.push(snapshotState());
  restoreSnapshot(snap);
}

document.getElementById("undo").addEventListener("click", ()=>{
  doUndo();
});

document.getElementById("redo").addEventListener("click", ()=>{
  doRedo();
});

document.getElementById("clear").addEventListener("click", ()=>{
  pushHistory();
  entities = [];
  nextId = 1;
  polyTemp = []; lineTemp = []; arcTemp = []; circTemp = [];
  document.getElementById("out").value = "";
  redraw();
});

/* =========================
   Export (CSV / G-code / Pseudocode)
========================= */

function validateIRForExport(kind){
  // kind: "GCODE" | "PMIR" | "TEACH" | "CSV"
  if (!IR_PURPOSE) {
    throw new Error("IR ERROR: PURPOSE not defined");
  }

  if (IR_PURPOSE === "MACHINE") {
    if (IR_Z_STRATEGY !== "DECLARED") {
      throw new Error("IR ERROR: MACHINE purpose requires declared Z strategy");
    }
  }

  // Defensive: IR stores absolute coordinates (x_mm/y_mm). Reordering relies on this.
  for (const e of entities){
    if (e.type === "POINT"){
      if (!e.p || typeof e.p.x_mm !== "number" || typeof e.p.y_mm !== "number"){
        throw new Error("IR ERROR: Non-absolute coordinates detected on POINT");
      }
    }
    if (e.type === "LINE"){
      if (!e.A || !e.B) throw new Error("IR ERROR: LINE missing endpoints");
    }
  }
}

function exportPointsCSV(featureList){
  const d = U[state.units].decimals;
  let lines = ["FEATURE,N,X,Y,UNITS,SRC"];
  for (const f of featureList){
    const pts = flattenFeaturePoints(f);
    pts.forEach((p,i)=>{
      lines.push(`${f},${i+1},${mmToU(p.x_mm).toFixed(d)},${mmToU(p.y_mm).toFixed(d)},${state.units},${p.src}`);
    });
  }
  return lines.join("\n");
}


function buildSketchProgramEntities(featureList, ignoreBuckets){
  // Returns entities in creation order, filtered by scope + export intent.
  const allow = new Set(featureList);
  return entities.filter(e=>{
    if (!allow.has(e.feature)) return false;
    if (e.feature === "REF") return false; // never export reference geometry
    if (!ignoreBuckets) return true;
    // In sketch mode we still keep drill points, but treat them as "marks" not canned cycles.
    return true;
  });
}

function gcodeHeader(){
  const L=[];
  L.push("(PlotOMatic sketch export)");
  L.push(state.units==="in" ? "G20" : "G21");
  L.push("G90");
  L.push("G17");
  // Default feed (viewer-friendly). You can change later.
  L.push(state.units==="in" ? "F20.0" : "F500.0");
  return L;
}

function exportGCode(featureList){
  validateIRForExport("GCODE");

  if (IR_PURPOSE === "MACHINE"){
    throw new Error("MACHINE purpose not yet supported in v0.4j1 (Z semantics pending)");
  }
  // Sketch export: reproduce the drawing (ncviewer-friendly), symbolic (no sampled arc waypoints).
  const d = U[state.units].decimals;
  const ignoreBuckets = !!(document.getElementById("sketchExport") && isSketchExportEnabled());
  const markPoints = !!(document.getElementById("markPoints") && document.getElementById("markPoints").checked);

  const ents = buildSketchProgramEntities(featureList, ignoreBuckets);
  const L = gcodeHeader();

  function fmt(x_mm){ return mmToU(x_mm).toFixed(d); }

  function rapidToRec(p){
    L.push(`G00 X${fmt(p.x_mm)} Y${fmt(p.y_mm)}`);
  }
  function feedToRec(p){
    L.push(`G01 X${fmt(p.x_mm)} Y${fmt(p.y_mm)}`);
  }
  function arcToRec(endRec, cw, I_mm, J_mm){
    const g = cw ? "G02" : "G03";
    L.push(`${g} X${fmt(endRec.x_mm)} Y${fmt(endRec.y_mm)} I${fmt(I_mm)} J${fmt(J_mm)}`);
  }

  // v0.4j7: DRILL marks in SKETCH export are emitted as tiny circles (no crosshair tool motion).
  // POINT never emits motion.
  const markSize_u = (state.units==="in") ? 0.05 : 1.0; // 0.05" or 1mm
  const markSize_mm = uToMM(markSize_u);

  const drillMark_u = (state.units==="in") ? 0.03 : 0.75; // marker radius: 0.03" or 0.75mm
  const drillMark_mm = uToMM(drillMark_u);

  function drillMark(centerRec){
    // Represent a drill location as a small circle marker (two semicircles).
    circleTwoSemicircles(centerRec, drillMark_mm, true);
  }


  function drawPointMark(p){
    const x=p.x_mm, y=p.y_mm;
    // horizontal tick
    rapidToRec({x_mm:x - markSize_mm, y_mm:y});
    feedToRec({x_mm:x + markSize_mm, y_mm:y});
    // vertical tick
    rapidToRec({x_mm:x, y_mm:y - markSize_mm});
    feedToRec({x_mm:x, y_mm:y + markSize_mm});
  }

  function circleTwoSemicircles(centerRec, r_mm, ccw=true){
    // Start at (cx + r, cy)
    const start = {x_mm:centerRec.x_mm + r_mm, y_mm:centerRec.y_mm};
    const mid   = {x_mm:centerRec.x_mm - r_mm, y_mm:centerRec.y_mm};
    rapidToRec(start);
    // first half: start -> mid
    arcToRec(mid, !ccw, -r_mm, 0);
    // second half: mid -> start (center relative from mid is +r)
    arcToRec(start, !ccw, +r_mm, 0);
  }

  for (const e of ents){
    if (e.type==="POINT"){
      // POINT is datum/marker only. It never emits tool motion.
      // Back-compat: if a legacy snapshot stored DRILL points as POINT within feature DRILL,
      // treat them as DRILL marks in SKETCH export.
      if (e.feature==="DRILL"){
        drillMark(e.p);
      }
      continue;
    }

    if (e.type==="DRILL"){
      drillMark(e.p);
      continue;
    }

    if (e.type==="LINE"){
      rapidToRec(e.A);
      feedToRec(e.B);
      continue;
    }

    if (e.type==="POLYLINE"){
      if (!e.pts || e.pts.length<2) continue;
      rapidToRec(e.pts[0]);
      for (let i=1;i<e.pts.length;i++) feedToRec(e.pts[i]);
      if (e.closed) feedToRec(e.pts[0]);
      continue;
    }

    if (e.type==="ARC3"){
      const circ = circleFrom3(e.S, e.M, e.E);
      if (!circ) continue;
      const {cx, cy} = circ;

      const aS = angle(cx,cy,e.S.x_mm,e.S.y_mm);
      const aM = angle(cx,cy,e.M.x_mm,e.M.y_mm);
      const aE = angle(cx,cy,e.E.x_mm,e.E.y_mm);
      const sweepSE = mod2pi(aE - aS);
      const sweepSM = mod2pi(aM - aS);
      const ccw = (sweepSM <= sweepSE); // same as segments exporter

      // Move to start, then arc to end with I,J from start.
      rapidToRec(e.S);
      const I = cx - e.S.x_mm;
      const J = cy - e.S.y_mm;
      arcToRec(e.E, !ccw, I, J); // ccw => G03, cw => G02
      continue;
    }

    if (e.type==="CIRCLE2"){
      const r_mm = Math.hypot(e.RP.x_mm - e.C.x_mm, e.RP.y_mm - e.C.y_mm);
      if (r_mm < 1e-9) continue;
      // Default CCW for circle drawing
      circleTwoSemicircles(e.C, r_mm, true);
      continue;
    }
  }

  return L.join("\n");
}


function exportPseudoMaticIR(featureList){
  validateIRForExport("PMIR");
  // Strict PseudoMatic Core1 IR export (dictionary-synced).
  // Emits ONLY the Core1 vocabulary:
  //   UNITS UNITS_INCH|UNITS_MM
  //   DIST_MODE DIST_ABSOLUTE
  //   PLANE PLANE_XY
  //   MOTION MOVE_RAPID|MOVE_FEED|ARC_CW|ARC_CCW X .. Y .. [I .. J ..]
  //
  // This is the authoritative interchange format for round-tripping through PseudoMatic.
  const d = U[state.units].decimals;
  const ignoreBuckets = !!(document.getElementById("sketchExport") && isSketchExportEnabled());
  const markPoints = !!(document.getElementById("markPoints") && document.getElementById("markPoints").checked);

  const ents = buildSketchProgramEntities(featureList, ignoreBuckets);
  const L=[];

  // Header (minimal but explicit)
  L.push(state.units==="in" ? "UNITS UNITS_INCH" : "UNITS UNITS_MM");
  L.push("DIST_MODE DIST_ABSOLUTE");
  L.push("PLANE PLANE_XY");
  L.push(`PURPOSE ${IR_PURPOSE}`);

  function fmt(x_mm){ return mmToU(x_mm).toFixed(d); }
  function motion(kind, p){
    // kind: MOVE_RAPID or MOVE_FEED
    L.push(`MOTION ${kind} X ${fmt(p.x_mm)} Y ${fmt(p.y_mm)}`);
  }
  function arc(kind, endRec, I_mm, J_mm){
    // kind: ARC_CW or ARC_CCW
    L.push(`MOTION ${kind} X ${fmt(endRec.x_mm)} Y ${fmt(endRec.y_mm)} I ${fmt(I_mm)} J ${fmt(J_mm)}`);
  }

  // Point marks: render as small crosshairs using MOVE_RAPID/MOVE_FEED only.
  const markSize_u = (state.units==="in") ? 0.05 : 1.0; // 0.05" or 1mm
  const markSize_mm = uToMM(markSize_u);

  function drawPointMark(p){
    const x=p.x_mm, y=p.y_mm;
    // horizontal tick
    motion("MOVE_RAPID", {x_mm:x - markSize_mm, y_mm:y});
    motion("MOVE_FEED",  {x_mm:x + markSize_mm, y_mm:y});
    // vertical tick
    motion("MOVE_RAPID", {x_mm:x, y_mm:y - markSize_mm});
    motion("MOVE_FEED",  {x_mm:x, y_mm:y + markSize_mm});
  }

  function circleTwoSemicircles(centerRec, r_mm, ccw=true){
    // Represent circle as two semicircle arcs for maximum CNC/viewer compatibility.
    const start = {x_mm:centerRec.x_mm + r_mm, y_mm:centerRec.y_mm};
    const mid   = {x_mm:centerRec.x_mm - r_mm, y_mm:centerRec.y_mm};
    motion("MOVE_RAPID", start);
    // For Core1: ARC_CCW for ccw, ARC_CW for cw.
    const kind = ccw ? "ARC_CCW" : "ARC_CW";
    // start -> mid, center relative from start is (-r, 0)
    arc(kind, mid, -r_mm, 0);
    // mid -> start, center relative from mid is (+r, 0)
    arc(kind, start, +r_mm, 0);
  }

  for (const e of ents){
    if (e.type==="POINT"){
      // POINT is datum/marker only. It never emits tool motion.
      // Back-compat: if a legacy snapshot stored DRILL points as POINT within feature DRILL,
      // treat them as DRILL marks in SKETCH export.
      if (e.feature==="DRILL"){
        drillMark(e.p);
      }
      continue;
    }

    if (e.type==="DRILL"){
      drillMark(e.p);
      continue;
    }

    if (e.type==="LINE"){
      motion("MOVE_RAPID", e.A);
      motion("MOVE_FEED",  e.B);
      continue;
    }

    if (e.type==="POLYLINE"){
      if (!e.pts || e.pts.length<2) continue;
      motion("MOVE_RAPID", e.pts[0]);
      for (let i=1;i<e.pts.length;i++) motion("MOVE_FEED", e.pts[i]);
      if (e.closed) motion("MOVE_FEED", e.pts[0]);
      continue;
    }

    if (e.type==="ARC3"){
      const circ = circleFrom3(e.S, e.M, e.E);
      if (!circ) continue;
      const {cx, cy} = circ;

      const aS = angle(cx,cy,e.S.x_mm,e.S.y_mm);
      const aM = angle(cx,cy,e.M.x_mm,e.M.y_mm);
      const aE = angle(cx,cy,e.E.x_mm,e.E.y_mm);
      const sweepSE = mod2pi(aE - aS);
      const sweepSM = mod2pi(aM - aS);
      const ccw = (sweepSM <= sweepSE);

      motion("MOVE_RAPID", e.S);
      const I = cx - e.S.x_mm;
      const J = cy - e.S.y_mm;
      arc(ccw ? "ARC_CCW" : "ARC_CW", e.E, I, J);
      continue;
    }

    if (e.type==="CIRCLE2"){
      const r_mm = Math.hypot(e.RP.x_mm - e.C.x_mm, e.RP.y_mm - e.C.y_mm);
      if (r_mm < 1e-9) continue;
      circleTwoSemicircles(e.C, r_mm, true);
      continue;
    }
  }

  return L.join("\n");
}

  const drillMark_u = (state.units==="in") ? 0.03 : 0.75; // marker radius: 0.03" or 0.75mm
  const drillMark_mm = uToMM(drillMark_u);

  function drillMark(centerRec){
    // Represent a drill location as a small circle marker (two semicircles).
    circleTwoSemicircles(centerRec, drillMark_mm, true);
  }


function exportPseudo(featureList){
  // Sketch export in a PseudoMatic-friendly, symbolic form (no sampled points).
  const d = U[state.units].decimals;
  const ignoreBuckets = !!(document.getElementById("sketchExport") && isSketchExportEnabled());
  const markPoints = !!(document.getElementById("markPoints") && document.getElementById("markPoints").checked);
  const verb = document.getElementById("psVerb").value;

  const ents = buildSketchProgramEntities(featureList, ignoreBuckets);
  let L=[];
  L.push(`OUTPUT "PlotOMatic sketch export"`);
  L.push(`SET UNITS = "${state.units}"`);
  L.push(`SET PLANE = "G17"`);
  L.push(`SET DISTANCE_MODE = "ABS"`);
  L.push(`SET FEED = ${state.units==="in" ? "20.0" : "500.0"}`);

  function fmt(x_mm){ return mmToU(x_mm).toFixed(d); }

  const markSize_u = (state.units==="in") ? 0.05 : 1.0;
  const markSize_mm = uToMM(markSize_u);

  function rapid(p){ L.push(`RAPID_TO  X=${fmt(p.x_mm)}  Y=${fmt(p.y_mm)}`); }
  function feed(p){ L.push(`${verb}  X=${fmt(p.x_mm)}  Y=${fmt(p.y_mm)}`); }
  function arc(end, ccw, I_mm, J_mm){
    const a = ccw ? "ARC_CCW_TO" : "ARC_CW_TO";
    L.push(`${a}  X=${fmt(end.x_mm)}  Y=${fmt(end.y_mm)}  I=${fmt(I_mm)}  J=${fmt(J_mm)}`);
  }

  function mark(p){
    const x=p.x_mm, y=p.y_mm;
    L.push(`MARK_POINT  X=${fmt(x)}  Y=${fmt(y)}  STYLE="CROSS"  SIZE=${mmToU(markSize_mm).toFixed(d)}`);
  }

  function circleTwoSemis(centerRec, r_mm, ccw=true){
    const start = {x_mm:centerRec.x_mm + r_mm, y_mm:centerRec.y_mm};
    const mid   = {x_mm:centerRec.x_mm - r_mm, y_mm:centerRec.y_mm};
    rapid(start);
    arc(mid, ccw, -r_mm, 0);
    arc(start, ccw, +r_mm, 0);
  }

  for (const e of ents){
    if (e.type==="POINT"){
      if (markPoints) mark(e.p);
      continue;
    }
    if (e.type==="LINE"){
      rapid(e.A);
      feed(e.B);
      continue;
    }
    if (e.type==="POLYLINE"){
      if (!e.pts || e.pts.length<2) continue;
      rapid(e.pts[0]);
      for (let i=1;i<e.pts.length;i++) feed(e.pts[i]);
      if (e.closed) feed(e.pts[0]);
      continue;
    }
    if (e.type==="ARC3"){
      const circ = circleFrom3(e.S, e.M, e.E);
      if (!circ) continue;
      const {cx, cy} = circ;

      const aS = angle(cx,cy,e.S.x_mm,e.S.y_mm);
      const aM = angle(cx,cy,e.M.x_mm,e.M.y_mm);
      const aE = angle(cx,cy,e.E.x_mm,e.E.y_mm);
      const sweepSE = mod2pi(aE - aS);
      const sweepSM = mod2pi(aM - aS);
      const ccw = (sweepSM <= sweepSE);

      rapid(e.S);
      const I = cx - e.S.x_mm;
      const J = cy - e.S.y_mm;
      arc(e.E, ccw, I, J);
      continue;
    }
    if (e.type==="CIRCLE2"){
      const r_mm = Math.hypot(e.RP.x_mm - e.C.x_mm, e.RP.y_mm - e.C.y_mm);
      if (r_mm < 1e-9) continue;
      circleTwoSemis(e.C, r_mm, true);
      continue;
    }
  }

  return L.join("\n");
}

document.getElementById("export").addEventListener("click", ()=>{
  const mode = document.getElementById("exportMode").value;
  const scope = getExportScope();
  const featureList = (scope==="active") ? [activeFeature] : FEATURES;

  const out = document.getElementById("out");
  try {
    let text = "";
    if (mode==="csv") text = exportPointsCSV(featureList);
    else if (mode==="gcode") text = exportGCode(featureList);
    else if (mode==="pmir") text = exportPseudoMaticIR(featureList);
    else text = exportPseudo(featureList);

    out.value = text;
    out.select();
  } catch (err){
    const msg = (err && err.message) ? err.message : String(err);
    out.value = `Status: error
${msg}`;
    out.select();
  }
});


/* =========================
   Session Snapshot (for intent vs reality debugging)
========================= */
function makeSessionSnapshot(){
  const now = new Date();
  const stamp = now.toISOString();

  const csvModeSel = document.getElementById("csvMode");
  const csvMode = csvModeSel ? csvModeSel.value : "segments";

  const snapshot = {
    app: "PlotOMatic",
    version: "v0.4j1-snapshot",
    timestamp: stamp,
    state: JSON.parse(JSON.stringify(state)),
    ui: {
      activeFeature,
      tool,
      polyClosed: (document.getElementById("polyClosed") ? document.getElementById("polyClosed").checked : null),
      gridStep_u: state.gridStep_u,
      majorEvery: state.majorEvery,
      viewWidth_u: state.viewWidth_u,
      coordFlavor: state.coordFlavor,
      x0_u: Number(document.getElementById("x0").value),
      y0_u: Number(document.getElementById("y0").value),
      snapEnabled: (document.getElementById("snap") ? document.getElementById("snap").checked : null),
      sampleStep_u: Number(document.getElementById("sampleStep").value),
      csvMode
    },
    entities,
    temps: {
      polyTemp,
      lineTemp,
      arcTemp,
      circTemp
    },
    exports: {
      active: {
        segmentsCSV: exportSegmentsCSV(activeFeature),
        waypointsCSV: exportWaypointsCSV(activeFeature)
      }
    },
    notes: "Upload this JSON back to ChatGPT for analysis. It contains your entities, settings, and the two main export views."
  };

  return snapshot;
}

function downloadText(filename, content){
  const blob = new Blob([content], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2500);
}

const snapshotBtn = document.getElementById("snapshot");
if (snapshotBtn){
  snapshotBtn.addEventListener("click", ()=>{
    const snap = makeSessionSnapshot();
    const safeStamp = snap.timestamp.replace(/[:.]/g,"-");
    downloadText(`plotomatic_snapshot_${safeStamp}.json`, JSON.stringify(snap, null, 2));
  });
}


// =========================
// Load Saved Session... (native PlotOMatic session)
// =========================
function syncConfigInputsFromState(){
  // Config panel fields (best-effort)
  try {
    const elU = document.getElementById("units"); if (elU) elU.value = state.units;
    const elGS = document.getElementById("gridStep"); if (elGS) elGS.value = String(state.gridStep_u);
    const elME = document.getElementById("majorEvery"); if (elME) elME.value = String(state.majorEvery);
    const elVW = document.getElementById("viewWidth"); if (elVW) elVW.value = String(state.viewWidth_u);
    const elCF = document.getElementById("coordFlavor"); if (elCF) elCF.value = String(state.coordFlavor || "haas");
  } catch(e){}
}

function applySavedSession(sess){
  if (!sess || sess.format !== "PlotOMaticSession") {
    alert("Not a PlotOMatic session file.");
    return;
  }
  if (!sess.state || !Array.isArray(sess.entities)) {
    alert("Session file is missing required fields.");
    return;
  }

  // Replace canonical authoring state
  state = JSON.parse(JSON.stringify(sess.state));
  entities = JSON.parse(JSON.stringify(sess.entities));
  nextId = Number.isFinite(sess.nextId) ? sess.nextId : (Math.max(0, ...entities.map(e=>e.id||0)) + 1);

  // Reset transient interaction state
  polyTemp = [];
  arcTemp = null;
  circTemp = null;
  rectTemp = null;
  dragging = false;
  draggingZero = false;

  // Reset undo/redo history (session load is a new baseline)
  try { undoStack.length = 0; redoStack.length = 0; } catch(e){}

  // Underlay restore
  if (sess.underlay){
    underlay.opacity = Number.isFinite(sess.underlay.opacity) ? sess.underlay.opacity : underlay.opacity;
    underlay.mmPerPx = Number.isFinite(sess.underlay.mmPerPx) ? sess.underlay.mmPerPx : underlay.mmPerPx;
    underlay.x_mm = Number.isFinite(sess.underlay.x_mm) ? sess.underlay.x_mm : underlay.x_mm;
    underlay.y_mm = Number.isFinite(sess.underlay.y_mm) ? sess.underlay.y_mm : underlay.y_mm;
    underlay.locked = !!sess.underlay.locked;
    underlay.name = sess.underlay.name || null;
    underlay.mime = sess.underlay.mime || null;
    underlay.dataUrl = sess.underlay.dataUrl || null;

    if (underlay.dataUrl){
      const img = new Image();
      img.onload = ()=>{
        underlay.img = img;
        try { syncUnderlayInputs(); } catch(e){}
        redraw();
      };
      img.onerror = ()=>{
        underlay.img = null;
        underlay.dataUrl = null;
        try { syncUnderlayInputs(); } catch(e){}
        redraw();
        alert("Loaded session, but underlay image could not be restored.");
      };
      img.src = underlay.dataUrl;
    } else {
      underlay.img = null;
      try { syncUnderlayInputs(); } catch(e){}
    }
  } else {
    // No underlay section in session
    underlay.img = null;
    underlay.dataUrl = null;
    try { syncUnderlayInputs(); } catch(e){}
  }

  // Sync config UI + redraw
  syncConfigInputsFromState();
  try { refreshUI(); } catch(e){}
  try { updateLiveCSV(); } catch(e){}
  redraw();
}

// =========================
// Save Session As... (native PlotOMatic session)
// =========================
function makeSavedSession(){
  // Ensure latest underlay inputs are reflected
  try { readUnderlayInputsToState(); } catch(e){}

  const stamp = new Date().toISOString();
  const underlayDataUrl =
    (underlay && underlay.dataUrl) ? underlay.dataUrl :
    (underlay && underlay.img && typeof underlay.img.src === "string" && underlay.img.src.startsWith("data:")) ? underlay.img.src :
    null;

  return {
    format: "PlotOMaticSession",
    version: "v0.5c1",
    timestamp: stamp,

    // Canonical authoring state
    state: JSON.parse(JSON.stringify(state)),
    entities: JSON.parse(JSON.stringify(entities)),
    nextId: nextId,

    // Underlay (portable)
    underlay: {
      hasImage: !!underlayDataUrl,
      opacity: underlay.opacity,
      mmPerPx: underlay.mmPerPx,
      x_mm: underlay.x_mm,
      y_mm: underlay.y_mm,
      locked: underlay.locked,
      name: underlay.name || null,
      mime: underlay.mime || null,
      dataUrl: underlayDataUrl
    },

    // Notes: Exports are intentionally NOT embedded (regenerable)
    notes: "Native PlotOMatic session save. Load to resume authoring. Exports (G-code/IR/CSV) are regenerated from entities + state."
  };
}

function suggestSessionFilename(tsIso){
  // plotomatic_session_2025-12-27T03-12-45Z.json (colon-safe)
  const safe = String(tsIso || new Date().toISOString()).replace(/[:.]/g,"-");
  return `plotomatic_session_${safe}.json`;
}

const saveSessionBtn = document.getElementById("saveSessionAs");
if (saveSessionBtn){
  saveSessionBtn.addEventListener("click", ()=>{
    const sess = makeSavedSession();
    downloadText(suggestSessionFilename(sess.timestamp), JSON.stringify(sess, null, 2));
  });
}


// Load Saved Session...
const loadSessionBtn = document.getElementById("loadSession");
const loadSessionFile = document.getElementById("loadSessionFile");

if (loadSessionBtn && loadSessionFile){
  loadSessionBtn.addEventListener("click", ()=>{
    loadSessionFile.value = "";
    loadSessionFile.click();
  });

  loadSessionFile.addEventListener("change", ()=>{
    const f = loadSessionFile.files && loadSessionFile.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try {
        const sess = JSON.parse(String(reader.result || ""));
        applySavedSession(sess);
      } catch(e){
        alert("Could not load session JSON. " + e);
      }
    };
    reader.readAsText(f);
  });
}


/* =========================
   Init
========================= */

const copyCsvBtn = document.getElementById("copyCsv");
if (copyCsvBtn){
  copyCsvBtn.addEventListener("click", ()=>{
    const el = document.getElementById("csvLive");
    if (!el) return;
    el.select();
    try { document.execCommand("copy"); } catch(e){}
  });
}


(function init(){
  state.units = document.getElementById("units").value;
  state.gridStep_u = Number(document.getElementById("gridStep").value);
  state.majorEvery = Math.max(1, Math.floor(Number(document.getElementById("majorEvery").value)));
  state.viewWidth_u = Number(document.getElementById("viewWidth").value);
  state.coordFlavor = document.getElementById("coordFlavor").value;
  const _fh = document.getElementById("featureHint");
  if (_fh) _fh.textContent = featureHints[activeFeature];
  setPolyClosedUIEnabled(tool==="POLYLINE");
  if (tool==="POLYLINE") syncPolyClosedDefault();
  redraw();
})();
</script>

</body>
</html>

